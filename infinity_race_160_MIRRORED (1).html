<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Infinity Race - ULTRA SAFE MOBILE üí™</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 32px;
            font-family: Arial, sans-serif;
            text-align: center;
            line-height: 1.5;
        }
        
        /* üì± MOBƒ∞L KONTROLLER */
        .mobile-controls {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }
        
        /* üì∑ CAMERA MODE BUTTON - SOL √úST */
        #cameraBtn {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 101;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        #cameraBtn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }
        
        /* üéÆ STEERING - SOL ALT */
        #steeringPad {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        .steering-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .steering-arrow {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.1s;
        }
        .steering-arrow:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
        }
        #leftArrow {
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
        }
        #rightArrow {
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        /* üöÄ ACCELERATION - SAƒû ALT */
        #accelPad {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        .accel-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .accel-arrow {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.1s;
        }
        .accel-arrow:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
        }
        #upArrow {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        #downArrow {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* üéÆ VR BUTTON */
        #vrBtn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 101;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        #vrBtn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }
        #vrBtn.vr-active {
            background: rgba(100, 255, 100, 0.3);
            border-color: rgba(100, 255, 100, 0.5);
        }
        
        @media (min-width: 1024px) and (hover: hover) and (pointer: fine) {
            #cameraBtn, #steeringPad, #accelPad {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Welcome to Su Su Land!<br>ARE YOU READY?</div>

    <!-- üì± MOBƒ∞L KONTROLLER -->
    <div class="mobile-controls">
        <div id="cameraBtn">üì∑</div>
        <div id="vrBtn">ü•Ω</div>
        
        <div id="steeringPad">
            <div class="steering-container">
                <div class="steering-arrow" id="leftArrow">‚Üê</div>
                <div class="steering-arrow" id="rightArrow">‚Üí</div>
            </div>
        </div>
        
        <div id="accelPad">
            <div class="accel-container">
                <div class="accel-arrow" id="upArrow">‚Üë</div>
                <div class="accel-arrow" id="downArrow">‚Üì</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIPhone = /iPhone/i.test(navigator.userAgent);
        const isTablet = /iPad|Android/i.test(navigator.userAgent) && window.innerWidth >= 768;
        const isPhone = isMobile && !isTablet;  // üì± TELEFON TESPƒ∞Tƒ∞ - Tablet deƒüilse telefon!
        const screenSize = Math.max(window.innerWidth, window.innerHeight);
        
        // üéØ Cihaz g√ºc√º tespiti
        const deviceMemory = navigator.deviceMemory || 4;
        const deviceCores = navigator.hardwareConcurrency || 4;
        const isLowEnd = isMobile && !isTablet && (deviceMemory <= 3 || deviceCores <= 4);
        
        console.log('üì± Device Info:', { 
            isMobile, isIPhone, isTablet, isPhone, isLowEnd,
            screenSize, deviceMemory, deviceCores,
            pixelRatio: window.devicePixelRatio
        });
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);

        // ============ üåßÔ∏è ULTRA GER√áEK√áƒ∞ KATMANLI YAƒûMUR - G√ñZ√úN√úN √ñN√úNDEKƒ∞ CAM Gƒ∞Bƒ∞! ============
        let rainLayers = [];
        let rainActive = false;

        function createRainSystem() {
            const layers = [];
            
            // üéØ 3 KATMAN YAƒûMUR - Yakƒ±ndan uzaƒüa!
            // KATMAN 1: TAM KAMERANIN √ñN√úNDEKƒ∞ CAM (en belirgin, en yava≈ü)
            // KATMAN 2: Orta mesafe
            // KATMAN 3: Uzak plan
            
            // üì± TELEFON OPTƒ∞Mƒ∞ZASYONU: Par√ßacƒ±k sayƒ±sƒ± azaltƒ±ldƒ± ama g√∂r√ºn√ºrl√ºk korundu!
            const layerConfigs = [
                {
                    name: 'EXTREME_CLOSE',
                    count: isPhone ? 60 : (isTablet ? 120 : 180),  // üì± 80‚Üí60 (optimize!)
                    minDist: 2,      // Kameraya 2-8 birim mesafe (√áOK YAKIN!)
                    maxDist: 8,
                    minLength: 2.5,  // √áok uzun damlalar
                    maxLength: 4.5,
                    velocity: 0.4,   // √áok yava≈ü d√º≈ü√ºyor (parallax)
                    opacity: 0.85,   // √áok belirgin
                    size: 2.5       // En kalƒ±n
                },
                {
                    name: 'CLOSE',
                    count: isPhone ? 120 : (isTablet ? 250 : 400),  // üì± 150‚Üí120 (optimize!)
                    minDist: 8,      // 8-25 birim
                    maxDist: 25,
                    minLength: 1.5,
                    maxLength: 3.0,
                    velocity: 0.7,
                    opacity: 0.7,
                    size: 1.8
                },
                {
                    name: 'MEDIUM',
                    count: isPhone ? 150 : (isTablet ? 350 : 600),  // üì± 200‚Üí150 (optimize!)
                    minDist: 25,     // 25-80 birim
                    maxDist: 80,
                    minLength: 1.0,
                    maxLength: 2.0,
                    velocity: 1.0,
                    opacity: 0.5,
                    size: 1.2
                },
                {
                    name: 'FAR',
                    count: isPhone ? 100 : (isTablet ? 250 : 400),  // üì± 150‚Üí100 (optimize!)
                    minDist: 80,     // 80-150 birim (uzak)
                    maxDist: 150,
                    minLength: 0.5,
                    maxLength: 1.2,
                    velocity: 1.3,
                    opacity: 0.3,
                    size: 0.8
                }
            ];
            
            layerConfigs.forEach(config => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.count * 6);
                const colors = new Float32Array(config.count * 6);
                const drops = [];
                
                for (let i = 0; i < config.count; i++) {
                    // Kamera etrafƒ±nda DAƒ∞RESEL daƒüƒ±lƒ±m
                    const angle = Math.random() * Math.PI * 2;
                    const distance = config.minDist + Math.random() * (config.maxDist - config.minDist);
                    
                    // Y ekseninde daha geni≈ü alan
                    const ySpread = distance < 15 ? 40 : 80; // Yakƒ±n olanlar daha dar alanda
                    
                    const drop = {
                        angle: angle,
                        distance: distance,
                        x: Math.cos(angle) * distance,
                        y: Math.random() * ySpread + 20,
                        z: Math.sin(angle) * distance,
                        velocity: config.velocity * (0.8 + Math.random() * 0.4),
                        length: config.minLength + Math.random() * (config.maxLength - config.minLength),
                        opacity: config.opacity * (0.8 + Math.random() * 0.4),
                        baseDistance: distance
                    };
                    drops.push(drop);
                    
                    const i6 = i * 6;
                    positions[i6] = drop.x;
                    positions[i6 + 1] = drop.y;
                    positions[i6 + 2] = drop.z;
                    positions[i6 + 3] = drop.x;
                    positions[i6 + 4] = drop.y - drop.length;
                    positions[i6 + 5] = drop.z;
                    
                    // Yakƒ±n = daha parlak!
                    const brightness = (1.0 - (distance / config.maxDist) * 0.4) * drop.opacity;
                    colors[i6] = colors[i6 + 1] = colors[i6 + 2] = brightness;
                    colors[i6 + 3] = colors[i6 + 4] = colors[i6 + 5] = brightness * 0.6;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: config.opacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: config.name === 'EXTREME_CLOSE' ? false : true // √ñn cam her zaman √∂nde!
                });
                
                const mesh = new THREE.LineSegments(geometry, material);
                mesh.renderOrder = config.name === 'EXTREME_CLOSE' ? 999 : 0; // En √∂nde render et!
                // üì± TELEFONDA frustumCulled = false (her zaman g√∂r√ºns√ºn!)
                mesh.frustumCulled = isPhone ? false : true;
                
                layers.push({
                    mesh: mesh,
                    drops: drops,
                    config: config
                });
            });
            
            return layers;
        }

        function updateRain() {
            // üì± TELEFONDA: rainActive kontrol√º YOK! Her zaman √ßalƒ±≈üsƒ±n!
            // üì± TELEFONDA: cameraMode kontrol√º YOK! Her modda g√∂r√ºns√ºn!
            if (!rainLayers.length || !car || !camera) return;
            
            // üì± TELEFON DEƒûƒ∞LSE orijinal kontroller ge√ßerli
            if (!isPhone && (!rainActive || cameraMode !== 1)) return;
            
            const carPos = car.position;
            const cameraWorldPos = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPos);
            
            rainLayers.forEach(layer => {
                const positions = layer.mesh.geometry.attributes.position.array;
                const colors = layer.mesh.geometry.attributes.color.array;
                
                layer.drops.forEach((drop, i) => {
                    // A≈üaƒüƒ± d√º≈ü!
                    drop.y -= drop.velocity * 0.9; // Ekstra yava≈ü
                    
                    // Yere deƒüdi mi?
                    if (drop.y < -15) {
                        // Yeniden ba≈ülat - kamera/araba pozisyonuna g√∂re
                        const angle = Math.random() * Math.PI * 2;
                        const distance = layer.config.minDist + Math.random() * (layer.config.maxDist - layer.config.minDist);
                        
                        drop.angle = angle;
                        drop.distance = distance;
                        drop.baseDistance = distance;
                        drop.y = 80 + Math.random() * 40;
                        drop.velocity = layer.config.velocity * (0.8 + Math.random() * 0.4);
                        drop.length = layer.config.minLength + Math.random() * (layer.config.maxLength - layer.config.minLength);
                    }
                    
                    // Kamera/araba etrafƒ±nda kalsƒ±n
                    drop.x = cameraWorldPos.x + Math.cos(drop.angle) * drop.distance;
                    drop.z = cameraWorldPos.z + Math.sin(drop.angle) * drop.distance;
                    
                    // Pozisyonlarƒ± yaz
                    const i6 = i * 6;
                    positions[i6] = drop.x;
                    positions[i6 + 1] = drop.y;
                    positions[i6 + 2] = drop.z;
                    positions[i6 + 3] = drop.x;
                    positions[i6 + 4] = drop.y - drop.length;
                    positions[i6 + 5] = drop.z;
                    
                    // Renk - mesafeye g√∂re
                    const brightness = (1.0 - (drop.distance / layer.config.maxDist) * 0.4) * drop.opacity;
                    colors[i6] = colors[i6 + 1] = colors[i6 + 2] = brightness;
                    colors[i6 + 3] = colors[i6 + 4] = colors[i6 + 5] = brightness * 0.6;
                });
                
                layer.mesh.geometry.attributes.position.needsUpdate = true;
                layer.mesh.geometry.attributes.color.needsUpdate = true;
            });
        }
        // ============ üåßÔ∏è KATMANLI YAƒûMUR Sƒ∞STEMƒ∞ SONU ============
        
        // üì± PROFESYONEL MOBƒ∞L RENDERER - ULTRA OPTƒ∞Mƒ∞ZE!
        const renderer = new THREE.WebGLRenderer({ 
            antialias: isTablet,  // üì± Tablet'te antialias A√áIK!
            powerPreference: "high-performance",
            precision: isTablet ? "highp" : (isMobile ? "mediump" : "highp"),
            stencil: false,
            depth: true,
            alpha: false,
            logarithmicDepthBuffer: false
        });
        
        // üì± AKILLI PIXEL RATIO - Performans + Netlik dengesi!
        const pixelRatio = isMobile && !isTablet ? 
            1.0 :  // üì± T√úM TELEFONLAR: 1.0 (iPhone 15 dahil!)
            (isTablet ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2.0));
        
        console.log('üé® Pixel Ratio:', pixelRatio);
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // üéØ SHADOW KAPALI - Yol yansƒ±masƒ±na karƒ±≈ümasƒ±n!
        renderer.shadowMap.enabled = false;
        // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.physicallyCorrectLights = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        // ü•Ω VR SUPPORT - Ama buton g√∂sterme!
        renderer.xr.enabled = true;
        
        document.body.appendChild(renderer.domElement);
        
        // üåßÔ∏è KATMANLI YAƒûMUR Sƒ∞STEMƒ∞Nƒ∞ BA≈ûLAT
        rainLayers = createRainSystem();
        rainLayers.forEach(layer => {
            // üì± TELEFONDA yaƒümur ba≈ülangƒ±√ßta A√áIK, diƒüerlerinde kapalƒ±
            layer.mesh.visible = isPhone ? true : false;
            scene.add(layer.mesh);
        });
        // üì± TELEFONDA rainActive = true (her zaman yaƒüƒ±yor!)
        if (isPhone) {
            rainActive = true;
            console.log(`üåßÔ∏è TELEFON: ${rainLayers.length} katmanlƒ± yaƒümur AKTƒ∞F! (${60+120+150+100} par√ßacƒ±k)`);
        } else {
            console.log(`üåßÔ∏è ${rainLayers.length} katmanlƒ± yaƒümur sistemi hazƒ±r!`);
        }
        
        // üöó MIRROR - ORƒ∞Jƒ∞NAL AYARLAR + YAZI KALƒ∞TESƒ∞ ARTIRILDI!
        const mirrorRes = isPhone ? 
            (screenSize <= 800 ? 256 : 384) :  // üì± Orijinal deƒüerler!
            (isTablet ? 512 : 1024);  // Desktop biraz daha y√ºksek kalite i√ßin
        
        console.log('ü™û Mirror Resolution:', mirrorRes);
        
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(mirrorRes, {
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter,
            magFilter: THREE.LinearFilter,
            encoding: THREE.sRGBEncoding,
            type: THREE.UnsignedByteType,
            anisotropy: isPhone ? 8 : 16  // ‚úÖ Daha y√ºksek anisotropy = daha net yazƒ±!
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
        scene.add(cubeCamera);
        
        // üõ£Ô∏è Road CubeCamera - SADECE TABLET VE DESKTOP ƒ∞√áƒ∞N! üì± TELEFONDA KAPALI!
        let roadCubeRenderTarget = null;
        let roadCubeCamera = null;
        let smoothRoadCameraPos = new THREE.Vector3(0, 10, 0);
        const roadCameraLerpFactor = 0.5;
        
        if (!isPhone) {  // ‚úÖ SADECE TABLET VE DESKTOP!
            const roadMirrorRes = isTablet ? 2048 : 2048;
            
            console.log('üõ£Ô∏è Road Mirror Resolution:', roadMirrorRes);
            
            roadCubeRenderTarget = new THREE.WebGLCubeRenderTarget(roadMirrorRes, {
                format: THREE.RGBAFormat,
                generateMipmaps: true,
                minFilter: THREE.LinearMipmapLinearFilter,
                magFilter: THREE.LinearFilter,
                encoding: THREE.sRGBEncoding,
                type: THREE.UnsignedByteType,
                anisotropy: isTablet ? 4 : 8
            });
            roadCubeCamera = new THREE.CubeCamera(0.1, 5000, roadCubeRenderTarget);
            roadCubeCamera.position.set(0, 10, 0);
            scene.add(roadCubeCamera);
        } else {
            console.log('üì± PHONE: Road reflection disabled for performance!');
        }
        
        // üåå PROFESYONEL SKYBOX ENVIRONMENT SYSTEM!
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        let currentEnvironmentMap = null;

        // ============ YENƒ∞: AKI≈ûKAN SKYBOX DEƒûƒ∞≈ûKENLERƒ∞ ============
        let universeTextures = [];
        let pourTextures = [];
        let currentUniverseIndex = 0;
        let nextUniverseIndex = 1;
        let currentPourIndex = 0;
        let fluidSkybox = null;
        let fluidMaterial = null;
        let fluidTime = 0;
        let isTransitioning = false;
        let skyboxTransition = 1.0;
        let transitionStartTime = 0;
        let lastSkyboxChange = 0;
        let lastPourTextureChange = 0;
        let cycleStartTime = 0;
        
        // üéØ OPTƒ∞Mƒ∞ZE D√ñNG√ú - 60 SANƒ∞YE (24s IN, 1s FULL, 35s OUT - UZUN GE√áƒ∞≈û!)
        const CYCLE_DURATION = 60000;           // Toplam d√∂ng√º 60 saniye
        const PURE_SPACE_DURATION = 0;          // Pure space YOK - hemen pour!
        const POUR_FADE_IN_START = 0;           // 0s'de pour HEMEN ba≈ülƒ±yor! ‚ö°
        const POUR_FADE_IN_DURATION = 24000;    // 0-24s: Pour uzun fade in
        const POUR_FULL_DURATION = 1000;        // 24-25s: Pour TAM g√∂r√ºn√ºr (1 saniye)
        const POUR_FADE_OUT_START = 25000;      // 25s'de pour geri √ßekiliyor
        const POUR_FADE_OUT_DURATION = 35000;   // 25-60s: Pour out + space blend (35 saniye - UZUN!)
        const NEW_SPACE_PURE_START = 60000;     // 60s: D√∂ng√º biter, yeni ba≈ülar!
        
        let fluidIntensity = 1.25;
        let waveAmplitude = 0.4;  // 0.75 ‚Üí 0.4 (daha az wave = daha az titreme!)
        let flowSpeed = 0.0125;
        let pourEffectIntensity = 0.0;
        let waveEffectIntensity = 0.0;

        // üì± MOBƒ∞L ƒ∞√áƒ∞N SADECE 15 UNIVERSE - HAFIZA KORUMASI!
        const FULL_UNIVERSE_URLS = [
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/1space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/2space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/3space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/4space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/5space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/6space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/7space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/8space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/9space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/10space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/11space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/12space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/13space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/14space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/15space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/16space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/17space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/18space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/19space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/20space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/21space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/22space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/23space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/24space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/25space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/26space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/27space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/28space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/29space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/30space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/31space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/32space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/33space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/34space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/35space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/36space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/37space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/38space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/39space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/40space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/41space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/42space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/43space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/44space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/45space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/46space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/47space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/48space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/49space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/50space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/51space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/52space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/53space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/54space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/55space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/56space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/57space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/58space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/59space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/60space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/61space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/62space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/63space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/64space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/65space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/66space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/67space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/68space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/69space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/70space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/71space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/72space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/73space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/74space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/75space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/76space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/77space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/78space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/79space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/80space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/81space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/82space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/83space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/84space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/85space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/86space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/87space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/88space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/89space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/90space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/91space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/92space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/93space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/94space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/95space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/96space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/97space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/98space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/99space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/100space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/101space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/102space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/103space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/104space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/105space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/106space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/107space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/108space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/109space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/110space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/111space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/112space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/113space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/114space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/115space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/116space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/117space.png",
            "https://raw.githubusercontent.com/busrasuhaydar/overthinkspace/main/assest/118space.png"
        ];

        // üì± MOBƒ∞L: Sadece 15 se√ßilmi≈ü universe (her 8. universe - √ße≈üitlilik i√ßin!)
        const MOBILE_UNIVERSE_URLS = [
            FULL_UNIVERSE_URLS[0],   // 1
            FULL_UNIVERSE_URLS[7],   // 8
            FULL_UNIVERSE_URLS[15],  // 16
            FULL_UNIVERSE_URLS[23],  // 24
            FULL_UNIVERSE_URLS[31],  // 32
            FULL_UNIVERSE_URLS[39],  // 40
            FULL_UNIVERSE_URLS[47],  // 48
            FULL_UNIVERSE_URLS[55],  // 56
            FULL_UNIVERSE_URLS[63],  // 64
            FULL_UNIVERSE_URLS[71],  // 72
            FULL_UNIVERSE_URLS[79],  // 80
            FULL_UNIVERSE_URLS[87],  // 88
            FULL_UNIVERSE_URLS[95],  // 96
            FULL_UNIVERSE_URLS[103], // 104
            FULL_UNIVERSE_URLS[111]  // 112
        ];
        
        // üéØ Cƒ∞HAZA G√ñRE UNIVERSE SE√áƒ∞Mƒ∞
        const UNIVERSE_TEXTURE_URLS = isMobile && !isTablet ? MOBILE_UNIVERSE_URLS : FULL_UNIVERSE_URLS;
        
        console.log(`üåå Universe Count: ${UNIVERSE_TEXTURE_URLS.length}`);

        // üé® POUR TEXTURES - SADECE TABLET VE DESKTOP ƒ∞√áƒ∞N! üì± TELEFONDA KAPALI!
        const POUR_TEXTURE_URLS = !isPhone ? [
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/1myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/2myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/3myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/4myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/5myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/6myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/7myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/8myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/9myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/10myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/11myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/12myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/13myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/14myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/15myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/16myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/17myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/18myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/19myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/20myspacetexture.png",
            "https://raw.githubusercontent.com/busrasuhaydar/newspaceoverthinktexture/main/assest/21myspacetexture.png"
        ] : [];  // ‚úÖ TELEFON: Pour textures kapalƒ±!
        
        console.log(`üé® Pour Texture Count: ${POUR_TEXTURE_URLS.length}`);

        // ============ YENƒ∞: SHADER KODLARI ============
        const fluidVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // üååüí• DRAMATIK UNIVERSE GE√áƒ∞≈û SHADER'I - SADECE RENK KARI≈ûIMI!
        const fluidFragmentShader = `
            precision highp float;
            
            uniform sampler2D uTexture;
            uniform sampler2D uNextTexture;
            uniform sampler2D uPourTexture;
            uniform float uTime;
            uniform float uFluidIntensity;
            uniform float uFlowSpeed;
            uniform float uWaveAmplitude;
            uniform float uTransition;
            uniform bool uIsTransitioning;
            uniform float uMirrorMode;
            uniform float uColorTemp;
            uniform float uPourEffectIntensity;
            uniform bool uPourMirrorX;  // ü™û Sola aynalama
            uniform bool uPourMirrorY;  // ü™û √úste aynalama
            
            varying vec2 vUv;
            
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }
            
            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            
            float fbm(vec2 st, int octaves) {
                float value = 0.0;
                float amplitude = 0.6;
                for (int i = 0; i < 8; i++) {
                    if (i >= octaves) break;
                    value += amplitude * noise(st);
                    st *= 2.2;
                    amplitude *= 0.55;
                }
                return value;
            }
            
            vec2 applyMirror(vec2 uv, float mode) {
                if (mode < 1.0) {
                    return uv;
                } else if (mode < 2.0) {
                    return vec2(1.0 - uv.x, uv.y);
                } else if (mode < 3.0) {
                    return vec2(uv.x, 1.0 - uv.y);
                } else {
                    return vec2(1.0 - uv.x, 1.0 - uv.y);
                }
            }
            
            vec3 applyColorTemp(vec3 color, float temp) {
                if (temp > 1.0) {
                    float warmth = temp - 1.0;
                    color.r += warmth * 0.3;
                    color.g += warmth * 0.15;
                } else {
                    float coolness = 1.0 - temp;
                    color.b += coolness * 0.3;
                    color.g += coolness * 0.1;
                }
                return clamp(color, 0.0, 1.0);
            }
            
            void main() {
                vec2 st = vUv;
                
                // üéØ SEAM SMOOTHER
                float seamBlend = 0.02;
                float edgeDistX = min(st.x, 1.0 - st.x);
                float edgeDistY = min(st.y, 1.0 - st.y);
                float edgeFactor = smoothstep(0.0, seamBlend, min(edgeDistX, edgeDistY));
                
                // UV D√úZELTME
                st.y = st.y * 0.91 + 0.045;
                
                float time = uTime * uFlowSpeed;
                vec2 mirroredSt = applyMirror(st, uMirrorMode);
                
                // ü™û Pour texture mirroring - sola ve √ºste aynalama
                vec2 pourUV = st;
                if (uPourMirrorX) {
                    pourUV.x = 1.0 - pourUV.x;  // Sola aynala
                }
                if (uPourMirrorY) {
                    pourUV.y = 1.0 - pourUV.y;  // √úste aynala
                }
                
                // Pour texture sampling (mirrored UV ile)
                vec4 pourSample = texture2D(uPourTexture, pourUV + time * 0.05);
                vec4 pourSample2 = texture2D(uPourTexture, pourUV * 1.3 - time * 0.03);
                float displacement = (pourSample.r + pourSample.g + pourSample.b) / 3.0;
                float displacement2 = (pourSample2.r + pourSample2.g + pourSample2.b) / 3.0;
                float combinedDisplacement = mix(displacement, displacement2, 0.5);
                
                // Flow vectors
                vec2 flow1 = vec2(sin(st.x * 3.0 + time * 0.8), cos(st.y * 3.0 + time * 0.8)) * 0.35;
                vec2 flow2 = vec2(cos(st.x * 6.0 - time * 0.6), sin(st.y * 6.0 - time * 0.6)) * 0.25;
                vec2 flow3 = vec2(sin(st.x * 1.5 + time * 1.2), cos(st.y * 1.5 - time * 1.0)) * 0.2;
                
                vec2 totalFlow = (flow1 + flow2 + flow3) * combinedDisplacement * uFluidIntensity * 0.8 * uPourEffectIntensity;
                
                // Waves
                float wave1 = sin(st.x * 8.0 + time * 0.8) * uWaveAmplitude * 0.04;
                float wave2 = cos(st.y * 7.0 - time * 0.6) * uWaveAmplitude * 0.04;
                float wave3 = sin(st.x * 4.0 + st.y * 4.0 + time * 0.5) * uWaveAmplitude * 0.03;
                
                vec2 permanentWave = vec2(wave1 + wave3, wave2 + wave3);
                totalFlow += vec2(wave1 + wave3, wave2 + wave3) * uPourEffectIntensity;
                
                // Turbulence
                float turbulence1 = fbm(st * 2.0 + time * 0.1, 4);
                float turbulence2 = fbm(st * 1.5 - time * 0.08, 3);
                totalFlow += vec2(turbulence1, turbulence2) * 0.03 * uFluidIntensity * uPourEffectIntensity;
                
                // Radial fade
                vec2 center = vec2(0.5, 0.5);
                float distFromCenter = distance(st, center);
                float radialFade = 1.0 - smoothstep(0.2, 0.65, distFromCenter);
                totalFlow *= radialFade;
                
                // Subtle alive flow
                vec2 aliveFlow = 0.01 * vec2(
                    sin(time * 0.05 + st.y * 3.0),
                    cos(time * 0.05 + st.x * 2.0)
                );
                
                vec2 distortedUV = mirroredSt + totalFlow + aliveFlow + permanentWave;
                vec4 originalColor = texture2D(uTexture, distortedUV);
                
                if (uIsTransitioning) {
                    vec2 nextDistortedUV = applyMirror(st, uMirrorMode) + totalFlow + aliveFlow + permanentWave;
                    vec4 nextColor = texture2D(uNextTexture, nextDistortedUV);
                    
                    // üååüí• DRAMATIK GE√áƒ∞≈û BA≈ûLIYOR!
                    
                    // 1Ô∏è‚É£ POUR MASK - Mirrored UV ile!
                    float pourMask1 = texture2D(uPourTexture, pourUV + time * 0.08).r;
                    float pourMask2 = texture2D(uPourTexture, pourUV * 1.4 - time * 0.06).g;
                    float pourMask3 = texture2D(uPourTexture, pourUV * 0.8 + time * 0.04).b;
                    
                    float yGradient = smoothstep(0.0, 0.9, 1.0 - st.y);
                    float xInfluence = sin(st.x * 3.14159) * 0.3;
                    float drippingMask = mix(mix(pourMask1, pourMask2, 0.5), pourMask3, 0.3);
                    
                    float finalDripMask = smoothstep(0.15, 0.85, drippingMask + yGradient * 0.8 + xInfluence);
                    
                    float transitionThreshold = uTransition * 2.2 - 0.6;
                    float revealMask = smoothstep(transitionThreshold - 0.5, transitionThreshold + 0.3, finalDripMask);
                    
                    // üé® POUR TEXTURE ƒ∞√áƒ∞NDE ƒ∞Kƒ∞ G√ñRSEL NET Bƒ∞R ≈ûEKƒ∞LDE KARI≈ûIYOR!
                    float pourPattern = drippingMask;
                    
                    // 2Ô∏è‚É£ PAR√áALANMA EFEKTƒ∞ - Pour'a ekstra texture!
                    float fragmentNoise = fbm(st * 8.0 + time * 0.3, 5);
                    
                    // 3Ô∏è‚É£ NET KARISIM B√ñLGESƒ∞ - %100 OPAK, Hƒ∞√á SOLUK DEƒûƒ∞L!
                    // 0-0.5: TAM eski texture
                    // 0.5: ƒ∞Kƒ∞Sƒ∞ de TAM g√∂r√ºn√ºr
                    // 0.5-1.0: TAM yeni texture
                    float sharpMix = smoothstep(0.1, 0.9, pourPattern);  // GENƒ∞≈û ge√ßi≈ü b√∂lgesi
                    
                    // 4Ô∏è‚É£ Fragment ile zenginle≈ütir
                    float enhancedMix = mix(sharpMix, fragmentNoise, 0.15);
                    enhancedMix = clamp(enhancedMix, 0.0, 1.0);
                    
                    // 5Ô∏è‚É£ ƒ∞Kƒ∞ TEXTURE'I TAM OPAKLIKTAYKEN KARI≈ûTIR!
                    // Her iki texture de %100 g√∂r√ºn√ºr - sadece oran deƒüi≈üiyor!
                    vec3 crispBlend = mix(
                        originalColor.rgb,  // TAM opak eski
                        nextColor.rgb,      // TAM opak yeni
                        enhancedMix         // Keskin oran
                    );
                    
                    // 6Ô∏è‚É£ EKSTRA CONTRAST - Renkler daha belirgin!
                    vec3 boostedOld = originalColor.rgb * 1.25;  // Eski texture boost
                    vec3 boostedNew = nextColor.rgb * 1.25;      // Yeni texture boost
                    
                    // 7Ô∏è‚É£ KESKIN KARISIM - ƒ∞ki texture net g√∂r√ºn√ºyor!
                    vec3 sharpDualBlend = mix(boostedOld, boostedNew, enhancedMix);
                    
                    // 8Ô∏è‚É£ RICH BLEND - Normalize et ama netliƒüi koru!
                    vec3 richBlend = mix(
                        crispBlend,
                        sharpDualBlend,
                        0.5  // %50 boosted, %50 normal - dengeli!
                    );
                    
                    // 9Ô∏è‚É£ FINAL - revealMask ile smooth ge√ßi≈ü!
                    originalColor.rgb = mix(originalColor.rgb, richBlend, revealMask);
                    
                    // üîü Son a≈üamada tam yeni g√∂rsele ge√ß
                    originalColor.rgb = mix(originalColor.rgb, nextColor.rgb, revealMask);
                    
                    // 1Ô∏è‚É£1Ô∏è‚É£ EDGE GLOW - Ge√ßi≈ü sƒ±nƒ±rlarƒ±nda hafif parƒ±ltƒ±!
                    float edgeGlow = smoothstep(0.35, 0.5, revealMask) * (1.0 - smoothstep(0.5, 0.65, revealMask));
                    originalColor.rgb += vec3(edgeGlow * 0.08);  // Hafif glow - ana karƒ±≈üƒ±m net kalsƒ±n!
                }
                
                vec3 finalColor = applyColorTemp(originalColor.rgb, uColorTemp);
                finalColor = mix(vec3(0.0), finalColor, edgeFactor);
                
                gl_FragColor = vec4(finalColor, originalColor.a);
            }
        `;
        
        
        // ============ YENƒ∞: TEKST√úR Y√úKLEME FONKSƒ∞YONLARI ============
        const textureLoader = new THREE.TextureLoader();
        let loadedUniverseCount = 0;
        let loadedPourCount = 0;
        
        // üé≤ M√úKEMMEL SHUFFLE Sƒ∞STEMƒ∞ - T√ºm texture'lar kullanƒ±lana kadar tekrar YOK!
        let universeShuffleQueue = [];
        let pourShuffleQueue = [];
        let texturesReady = false;
        
        // üéØ MASTER SHUFFLE QUEUE - T√ºm texture index'leri ba≈ütan shuffle!
        let masterUniverseQueue = [];
        let masterPourQueue = [];
        let universeQueuePosition = 0;
        let pourQueuePosition = 0;
        
        // üé® YENƒ∞: PROFESYONEL Bƒ∞RLE≈ûƒ∞K POOL Sƒ∞STEMƒ∞ (SADECE TABLET VE DESKTOP ƒ∞√áƒ∞N!)
        let combinedTexturePool = [];        // { type: 'pour'/'universe', index: number, isMirrored: boolean }
        let combinedPoolPosition = 0;        // Pool'daki pozisyon
        let consecutiveUniverseCount = 0;    // Ka√ß kez ard arda universe se√ßildi
        let lastSelectedType = null;         // Son se√ßilen tip
        let pourUsageCount = {};             // Her pour ka√ß kez kullanƒ±ldƒ± (max 2)

        // üì± AKILLI TEXTURE STREAMING - Ekran + Hafƒ±za bazlƒ±!
        let activeTextureIndices = new Set();
        
        // üì± ULTRA G√ú√áL√ú MOBƒ∞L OPTƒ∞Mƒ∞ZASYON - √á√ñKME YOK!
        // Texture limit: √áOK D√ú≈û√úK - Kesinlikle √ß√∂kmemeli!
        const MAX_LOADED_TEXTURES = isMobile && !isTablet ?
            (deviceMemory <= 3 ? 2 : (screenSize <= 800 ? 3 : 4)) :  // üì± 2-4 texture (ULTRA SAFE!)
            (isTablet ? 6 : 20);  // iPad: 6 (daha safe!), Desktop: 20
        
        const PRELOAD_DISTANCE = isMobile ? 2 : 3;
        
        console.log('üíæ Max Textures:', MAX_LOADED_TEXTURES);
        
        function loadFluidTextures() {
            
            // üé≤ MASTER SHUFFLE QUEUE OLU≈ûTUR - BA≈ûTAN T√úM Sƒ∞STEM HAZIR!
            // Universe: 0'dan UNIVERSE_TEXTURE_URLS.length-1'e kadar t√ºm index'ler
            for (let i = 0; i < UNIVERSE_TEXTURE_URLS.length; i++) {
                masterUniverseQueue.push(i);
            }
            // Pour: 0'dan POUR_TEXTURE_URLS.length-1'e kadar t√ºm index'ler
            for (let i = 0; i < POUR_TEXTURE_URLS.length; i++) {
                masterPourQueue.push(i);
            }
            
            // üé≤ SHUFFLE ET - Her a√ßƒ±lƒ±≈üta farklƒ± sƒ±ra!
            masterUniverseQueue = shuffleArray(masterUniverseQueue);
            masterPourQueue = shuffleArray(masterPourQueue);
            
            // üé® YENƒ∞: PROFESYONEL Bƒ∞RLE≈ûƒ∞K POOL OLU≈ûTUR (SADECE TABLET/DESKTOP!)
            if (!isPhone) {
                createCombinedTexturePool();
            }
            
            // ============================================
            // üöÄ INSTANT START - Mobilde SADECE 1+1 texture!
            // ============================================
            const quickStart = isMobile ? 1 : 2;  // üì± Mobil: TEK TEXTURE!
            
            // üé≤ MASTER QUEUE'dan ilk texture(lar) al!
            const firstUniverseIndices = isMobile ? 
                [masterUniverseQueue[0]] :  // üì± Mobil: Sadece 1!
                [masterUniverseQueue[0], masterUniverseQueue[1]];  // Desktop: 2
            universeQueuePosition = firstUniverseIndices.length;
            
            firstUniverseIndices.forEach((index, i) => {
                textureLoader.load(UNIVERSE_TEXTURE_URLS[index], (texture) => {
                    // üì± AGRESIF RESIZE - Hafƒ±za koruma ama kalite korunuyor!
                    if (isMobile && !isTablet) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = texture.image;
                        
                        // Daha agresif resize - √á√ñKME YOK!
                        let targetSize;
                        if (deviceMemory <= 3) {
                            targetSize = 768;   // D√º≈ü√ºk hafƒ±za: 768
                        } else if (screenSize <= 700) {
                            targetSize = 896;   // K√º√ß√ºk ekran: 896
                        } else if (screenSize <= 900) {
                            targetSize = 1024;  // Orta ekran: 1024
                        } else {
                            targetSize = 1152;  // B√ºy√ºk ekran: 1152
                        }
                        
                        canvas.width = targetSize;
                        canvas.height = targetSize;
                        
                        // ULTRA high quality resize!
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        texture.image = canvas;
                        texture.needsUpdate = true;
                        
                        console.log(`üìê Texture ${index} resized to: ${canvas.width}x${canvas.height} (mem: ${deviceMemory}GB)`);
                    }
                    
                    texture.encoding = THREE.sRGBEncoding;
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = isMobile ? 4 : 8;  // 2‚Üí4 (daha keskin!)
                    texture.generateMipmaps = true;
                    
                    universeTextures[index] = texture;
                    activeTextureIndices.add('u' + index);  // üì± Track aktif texture!
                    loadedUniverseCount++;
                    
                    // üì± Texture ba≈ülatma - TELEFONDA POUR BEKLEME!
                    const minStart = isMobile ? 1 : 2;
                    const pourReady = isPhone ? true : (loadedPourCount >= 1);  // ‚úÖ KEY FIX!
                    
                    if (loadedUniverseCount >= minStart && pourReady && !texturesReady) {
                        texturesReady = true;
                        createFluidSkybox();
                        
                        // üì± MOBƒ∞L: Geri kalanlarƒ± yava≈ü√ßa y√ºkle!
                        if (!isMobile) {
                            loadRemainingTextures();
                        } else {
                            loadTexturesLazy();  // Mobilde LAZY loading!
                        }
                    }
                });
            });
            
            // üé≤ MASTER QUEUE'dan ilk pour texture(lar) al!
            const firstPourIndices = isMobile ? 
                [masterPourQueue[0]] :  // üì± Mobil: Sadece 1!
                [masterPourQueue[0], masterPourQueue[1]];  // Desktop: 2
            pourQueuePosition = firstPourIndices.length;
            
            firstPourIndices.forEach((index, i) => {
                textureLoader.load(POUR_TEXTURE_URLS[index], (texture) => {
                    // üì± Mƒ∞Nƒ∞MUM RESIZE - Maksimum netlik!
                    if (isMobile && !isTablet) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = texture.image;
                        
                        let resizeFactor;
                        if (screenSize <= 700) {
                            resizeFactor = 2;
                        } else if (screenSize <= 900) {
                            resizeFactor = 1.75;
                        } else {
                            resizeFactor = 1.5;
                        }
                        
                        canvas.width = Math.max(1024, Math.floor(img.width / resizeFactor));
                        canvas.height = Math.max(1024, Math.floor(img.height / resizeFactor));
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        texture.image = canvas;
                        texture.needsUpdate = true;
                    }
                    
                    texture.wrapS = THREE.MirroredRepeatWrapping;
                    texture.wrapT = THREE.MirroredRepeatWrapping;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = isMobile ? 4 : 8;
                    texture.generateMipmaps = true;
                    
                    pourTextures[index] = texture;
                    activeTextureIndices.add('p' + index);  // üì± Track aktif texture!
                    loadedPourCount++;
                    
                    // üì± MOBƒ∞L: 1+1 texture ile ba≈üla! Desktop: 2+2
                    const minStart = isMobile ? 1 : 2;
                    if (loadedUniverseCount >= minStart && loadedPourCount >= 1 && !texturesReady) {
                        texturesReady = true;
                        createFluidSkybox();
                        
                        // üì± MOBƒ∞L: LAZY LOADING - yava≈ü yava≈ü y√ºkle!
                        // Desktop: Hƒ±zlƒ±ca t√ºm√ºn√º y√ºkle!
                        if (!isMobile) {
                            loadRemainingTextures();
                        } else {
                            // ƒ∞lk texture y√ºklendi, 5 saniye sonra lazy loading ba≈ülat!
                            setTimeout(loadTexturesLazy, 5000);
                        }
                    }
                });
            });
        }
        
        // üì± LAZY LOADING - Mobilde texture'larƒ± YAVA≈û√áa y√ºkle!
        let lazyLoadPosition = isMobile ? 1 : 2;  // ƒ∞lk ka√ßƒ±nƒ± y√ºkledik
        let isLoadingTexture = false;  // Loading lock!
        
        function loadTexturesLazy() {
            // üéØ TEK TEK y√ºkle - aynƒ± anda birden fazla y√ºkleme YOK!
            if (isLoadingTexture) return;
            if (lazyLoadPosition >= masterUniverseQueue.length) return;
            if (activeTextureIndices.size >= MAX_LOADED_TEXTURES) return;
            
            const index = masterUniverseQueue[lazyLoadPosition];
            lazyLoadPosition++;
            
            if (!universeTextures[index]) {
                loadUniverseTexture(index);
            } else {
                // Bu texture zaten y√ºkl√º, bir sonrakini dene
                setTimeout(loadTexturesLazy, 100);
            }
        }
        
        function loadUniverseTexture(index) {
            if (activeTextureIndices.size >= MAX_LOADED_TEXTURES) {
                setTimeout(() => loadUniverseTexture(index), 2000);  // 2 saniye bekle!
                return;
            }
            
            isLoadingTexture = true;  // Lock!
            
            textureLoader.load(UNIVERSE_TEXTURE_URLS[index], (texture) => {
                // üì± Mƒ∞Nƒ∞MUM RESIZE - Maksimum netlik!
                if (isMobile && !isTablet) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = texture.image;
                    
                    let resizeFactor;
                    if (screenSize <= 700) {
                        resizeFactor = 2;
                    } else if (screenSize <= 900) {
                        resizeFactor = 1.75;
                    } else {
                        resizeFactor = 1.5;
                    }
                    
                    canvas.width = Math.max(1024, Math.floor(img.width / resizeFactor));
                    canvas.height = Math.max(1024, Math.floor(img.height / resizeFactor));
                    
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    texture.image = canvas;
                    texture.needsUpdate = true;
                }
                
                texture.encoding = THREE.sRGBEncoding;
                texture.wrapS = THREE.MirroredRepeatWrapping;
                texture.wrapT = THREE.MirroredRepeatWrapping;
                texture.minFilter = THREE.LinearMipmapLinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.anisotropy = isMobile ? 4 : 8;
                texture.generateMipmaps = true;
                
                universeTextures[index] = texture;
                activeTextureIndices.add('u' + index);
                
                isLoadingTexture = false;  // Unlock!
                
                // üéØ Yava≈ü√ßa bir sonrakini y√ºkle - 3 saniye bekle!
                if (isMobile) {
                    setTimeout(loadTexturesLazy, 3000);
                } else {
                    setTimeout(loadTexturesLazy, 1000);
                }
            }, undefined, () => {
                // Error durumunda da unlock!
                isLoadingTexture = false;
                setTimeout(loadTexturesLazy, 2000);
            });
        }
        
        function loadRemainingTextures() {
            
            // üéØ MASTER QUEUE'dan kalan t√ºm universe texture'larƒ± y√ºkle (ilk ka√ßƒ±nƒ± atla)
            const startIndex = isMobile ? 1 : 2;
            for (let i = startIndex; i < masterUniverseQueue.length; i++) {
                const index = masterUniverseQueue[i];
                textureLoader.load(UNIVERSE_TEXTURE_URLS[index], (texture) => {
                    // üì± Mƒ∞Nƒ∞MUM RESIZE - Maksimum netlik!
                    if (isMobile && !isTablet) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = texture.image;
                        
                        let resizeFactor;
                        if (screenSize <= 700) {
                            resizeFactor = 2;
                        } else if (screenSize <= 900) {
                            resizeFactor = 1.75;
                        } else {
                            resizeFactor = 1.5;
                        }
                        
                        canvas.width = Math.max(1024, Math.floor(img.width / resizeFactor));
                        canvas.height = Math.max(1024, Math.floor(img.height / resizeFactor));
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        texture.image = canvas;
                        texture.needsUpdate = true;
                    }
                    
                    texture.encoding = THREE.sRGBEncoding;
                    texture.wrapS = THREE.MirroredRepeatWrapping;
                    texture.wrapT = THREE.MirroredRepeatWrapping;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = isMobile ? 4 : renderer.capabilities.getMaxAnisotropy();
                    texture.generateMipmaps = true;
                    
                    universeTextures[index] = texture;
                    loadedUniverseCount++;
                });
            }
            
            // üéØ Pour texture'larƒ± da y√ºkle
            for (let i = startIndex; i < masterPourQueue.length; i++) {
                const index = masterPourQueue[i];
                textureLoader.load(POUR_TEXTURE_URLS[index], (texture) => {
                    // üì± Mƒ∞Nƒ∞MUM RESIZE - Maksimum netlik!
                    if (isMobile && !isTablet) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = texture.image;
                        
                        let resizeFactor;
                        if (screenSize <= 700) {
                            resizeFactor = 2;
                        } else if (screenSize <= 900) {
                            resizeFactor = 1.75;
                        } else {
                            resizeFactor = 1.5;
                        }
                        
                        canvas.width = Math.max(1024, Math.floor(img.width / resizeFactor));
                        canvas.height = Math.max(1024, Math.floor(img.height / resizeFactor));
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        texture.image = canvas;
                        texture.needsUpdate = true;
                    }
                    
                    texture.wrapS = THREE.MirroredRepeatWrapping;
                    texture.wrapT = THREE.MirroredRepeatWrapping;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = isMobile ? 4 : renderer.capabilities.getMaxAnisotropy();
                    texture.generateMipmaps = true;
                    
                    pourTextures[index] = texture;
                    loadedPourCount++;
                });
            }
        }

        function checkFluidTexturesLoaded() {
            if (loadedUniverseCount >= UNIVERSE_TEXTURE_URLS.length && 
                loadedPourCount >= POUR_TEXTURE_URLS.length && 
                !texturesReady) {
                texturesReady = true;
                createFluidSkybox();
            }
        }

        // üé≤ SHUFFLE FONKSƒ∞YONLARI
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // üé® YENƒ∞: PROFESYONEL Bƒ∞RLE≈ûƒ∞K POOL OLU≈ûTUR
        function createCombinedTexturePool() {
            combinedTexturePool = [];
            combinedPoolPosition = 0;
            consecutiveUniverseCount = 0;
            pourUsageCount = {};  // Sƒ±fƒ±rla
            
            // 1. Her pour i√ßin kullanƒ±m sayacƒ±nƒ± ba≈ülat
            for (let i = 0; i < POUR_TEXTURE_URLS.length; i++) {
                pourUsageCount[i] = 0;  // Hen√ºz hi√ß kullanƒ±lmadƒ±
            }
            
            // 2. T√ºm texture'larƒ± ayrƒ± listeler halinde hazƒ±rla
            const pourList = [];
            const universeList = [];
            
            // Her pour 2 kez eklenecek (normal + mirrored)
            for (let i = 0; i < POUR_TEXTURE_URLS.length; i++) {
                pourList.push({ type: 'pour', index: i, isMirrored: false, pourId: `pour_${i}_normal` });
                pourList.push({ type: 'pour', index: i, isMirrored: true, pourId: `pour_${i}_mirror` });
            }
            
            // Universe'ler sadece 1 kez
            for (let i = 0; i < UNIVERSE_TEXTURE_URLS.length; i++) {
                universeList.push({ type: 'universe', index: i, isMirrored: false });
            }
            
            // 3. Her listeyi shuffle et
            const shuffledPour = shuffleArray(pourList);
            const shuffledUniverse = shuffleArray(universeList);
            
            let pourIndex = 0;
            let universeIndex = 0;
            let consecutiveU = 0;
            let lastPourIndex = -1;  // Son se√ßilen pour index'i
            
            // 4. ORGANƒ∞K RASTGELE SE√áIM - Kurallarla
            const totalTextures = pourList.length + universeList.length;  // 42 + 118 = 160
            
            console.log('üé® Pool olu≈üturuluyor:', {
                totalPour: pourList.length,
                totalUniverse: universeList.length,
                total: totalTextures
            });
            
            for (let i = 0; i < totalTextures; i++) {
                let canPickUniverse = (consecutiveU < 2) && (universeIndex < shuffledUniverse.length);
                let canPickPour = pourIndex < shuffledPour.length;
                
                // 2 kez ard arda universe olduysa, MUTLAKA pour se√ß
                if (consecutiveU >= 2) {
                    if (canPickPour) {
                        const pourItem = shuffledPour[pourIndex];
                        
                        // KURAL: Aynƒ± pour ard arda gelmemeli!
                        // Eƒüer son pour ile aynƒ±ysa, ba≈üka pour bul
                        if (pourItem.index === lastPourIndex) {
                            // Sonraki farklƒ± pour'u bul
                            let foundDifferent = false;
                            for (let j = pourIndex + 1; j < shuffledPour.length; j++) {
                                if (shuffledPour[j].index !== lastPourIndex) {
                                    // Swap yap
                                    [shuffledPour[pourIndex], shuffledPour[j]] = [shuffledPour[j], shuffledPour[pourIndex]];
                                    foundDifferent = true;
                                    break;
                                }
                            }
                            
                            if (!foundDifferent) {
                                // Farklƒ± pour bulunamadƒ±, bu pour'u kullan (pool sonuna yakƒ±nƒ±z)
                            }
                        }
                        
                        combinedTexturePool.push(shuffledPour[pourIndex]);
                        lastPourIndex = shuffledPour[pourIndex].index;
                        pourIndex++;
                        consecutiveU = 0;
                    } else {
                        // Pour kalmadƒ±ysa universe ekle
                        if (universeIndex < shuffledUniverse.length) {
                            combinedTexturePool.push(shuffledUniverse[universeIndex]);
                            universeIndex++;
                            consecutiveU++;
                            lastPourIndex = -1;
                        }
                    }
                } else {
                    // Rastgele se√ßim - %55 pour, %45 universe (pour biraz daha fazla!)
                    const pickPour = Math.random() < 0.55;
                    
                    if (pickPour && canPickPour) {
                        const pourItem = shuffledPour[pourIndex];
                        
                        // KURAL: Aynƒ± pour ard arda gelmemeli!
                        if (pourItem.index === lastPourIndex) {
                            // Sonraki farklƒ± pour'u bul
                            let foundDifferent = false;
                            for (let j = pourIndex + 1; j < shuffledPour.length; j++) {
                                if (shuffledPour[j].index !== lastPourIndex) {
                                    // Swap yap
                                    [shuffledPour[pourIndex], shuffledPour[j]] = [shuffledPour[j], shuffledPour[pourIndex]];
                                    foundDifferent = true;
                                    break;
                                }
                            }
                        }
                        
                        // Pour se√ß
                        combinedTexturePool.push(shuffledPour[pourIndex]);
                        lastPourIndex = shuffledPour[pourIndex].index;
                        pourIndex++;
                        consecutiveU = 0;
                    } else if (canPickUniverse) {
                        // Universe se√ß
                        combinedTexturePool.push(shuffledUniverse[universeIndex]);
                        universeIndex++;
                        consecutiveU++;
                        lastPourIndex = -1;
                    } else if (canPickPour) {
                        // Universe kalmadƒ±, pour se√ß
                        const pourItem = shuffledPour[pourIndex];
                        
                        // Aynƒ± pour kontrol√º
                        if (pourItem.index === lastPourIndex) {
                            for (let j = pourIndex + 1; j < shuffledPour.length; j++) {
                                if (shuffledPour[j].index !== lastPourIndex) {
                                    [shuffledPour[pourIndex], shuffledPour[j]] = [shuffledPour[j], shuffledPour[pourIndex]];
                                    break;
                                }
                            }
                        }
                        
                        combinedTexturePool.push(shuffledPour[pourIndex]);
                        lastPourIndex = shuffledPour[pourIndex].index;
                        pourIndex++;
                        consecutiveU = 0;
                    }
                }
            }
            
            console.log('üé® ORGANƒ∞K Pool Olu≈üturuldu:', {
                total: combinedTexturePool.length,
                pourNormal: combinedTexturePool.filter(t => t.type === 'pour' && !t.isMirrored).length,
                pourMirrored: combinedTexturePool.filter(t => t.type === 'pour' && t.isMirrored).length,
                universe: combinedTexturePool.filter(t => t.type === 'universe').length
            });
            
            // ƒ∞lk 40'ƒ± g√∂ster (debug i√ßin - PN=Pour Normal, PM=Pour Mirror, U=Universe)
            console.log('üìã ƒ∞lk 40 sƒ±ra:', 
                combinedTexturePool.slice(0, 40).map(t => {
                    if (t.type === 'pour') {
                        return t.isMirrored ? 'PM' : 'PN';
                    }
                    return 'U';
                }).join('-')
            );
            
            // Son kontrol: Max ard arda universe
            let maxConsecutive = 0;
            let currentConsecutive = 0;
            for (let i = 0; i < combinedTexturePool.length; i++) {
                if (combinedTexturePool[i].type === 'universe') {
                    currentConsecutive++;
                    maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                } else {
                    currentConsecutive = 0;
                }
            }
            console.log('‚úÖ Max ard arda universe:', maxConsecutive, '(olmasƒ± gereken: ‚â§2)');
            
            // Ard arda aynƒ± pour kontrol√º
            let hasConsecutiveSamePour = false;
            for (let i = 1; i < combinedTexturePool.length; i++) {
                if (combinedTexturePool[i].type === 'pour' && 
                    combinedTexturePool[i-1].type === 'pour' &&
                    combinedTexturePool[i].index === combinedTexturePool[i-1].index) {
                    hasConsecutiveSamePour = true;
                    console.warn('‚ö†Ô∏è Ard arda aynƒ± pour bulundu:', i, combinedTexturePool[i].index);
                }
            }
            if (!hasConsecutiveSamePour) {
                console.log('‚úÖ Ard arda aynƒ± pour YOK!');
            }
        }
        
        function getRandomUniverseIndex() {
            // üéØ MASTER QUEUE'dan sƒ±radaki texture'ƒ± al!
            let nextIndex = masterUniverseQueue[universeQueuePosition];
            
            // üì± Texture y√ºklenmemi≈üse bir sonrakini dene!
            let attempts = 0;
            while (!universeTextures[nextIndex] && attempts < masterUniverseQueue.length) {
                universeQueuePosition++;
                if (universeQueuePosition >= masterUniverseQueue.length) {
                    universeQueuePosition = 0;
                    masterUniverseQueue = shuffleArray(masterUniverseQueue);
                }
                nextIndex = masterUniverseQueue[universeQueuePosition];
                attempts++;
            }
            
            universeQueuePosition++;
            
            // üîÑ Queue bittiyse ba≈üa d√∂n + YENƒ∞DEN SHUFFLE!
            if (universeQueuePosition >= masterUniverseQueue.length) {
                universeQueuePosition = 0;
                masterUniverseQueue = shuffleArray(masterUniverseQueue);
            }
            
            return nextIndex;
        }
        
        function getRandomPourIndex() {
            // üì± TELEFONDA: Orjinal pour sistemi (hi√ßbir deƒüi≈üiklik yok!)
            if (isPhone) {
                let nextIndex = masterPourQueue[pourQueuePosition];
                
                let attempts = 0;
                while (!pourTextures[nextIndex] && attempts < masterPourQueue.length) {
                    pourQueuePosition++;
                    if (pourQueuePosition >= masterPourQueue.length) {
                        pourQueuePosition = 0;
                        masterPourQueue = shuffleArray(masterPourQueue);
                    }
                    nextIndex = masterPourQueue[pourQueuePosition];
                    attempts++;
                }
                
                pourQueuePosition++;
                
                if (pourQueuePosition >= masterPourQueue.length) {
                    pourQueuePosition = 0;
                    masterPourQueue = shuffleArray(masterPourQueue);
                }
                
                return { index: nextIndex, isMirrored: false };
            }
            
            // üíª TABLET/DESKTOP: PROFESYONEL Bƒ∞RLE≈ûƒ∞K POOL Sƒ∞STEMƒ∞!
            
            // Pool t√ºkendiyse, yeni pool olu≈ütur!
            if (combinedPoolPosition >= combinedTexturePool.length) {
                console.log('üîÑ Pool t√ºkendi! Yeni pool olu≈üturuluyor... (160 g√∂rsel)');
                createCombinedTexturePool();
            }
            
            // Pool'dan sƒ±radaki texture'ƒ± al
            const currentTexture = combinedTexturePool[combinedPoolPosition];
            combinedPoolPosition++;
            
            // Texture tipini sakla
            lastSelectedType = currentTexture.type;
            
            // Universe sayacƒ±nƒ± g√ºncelle
            if (currentTexture.type === 'universe') {
                consecutiveUniverseCount++;
            } else {
                consecutiveUniverseCount = 0;
            }
            
            const mirrorText = currentTexture.isMirrored ? 'ü™û MIRROR' : '‚ú® NORMAL';
            console.log(`üé® Se√ßildi: ${currentTexture.type.toUpperCase()} #${currentTexture.index} ${currentTexture.type === 'pour' ? mirrorText : ''} (U-saya√ß: ${consecutiveUniverseCount}, Pool: ${combinedPoolPosition}/${combinedTexturePool.length})`);
            
            return { 
                index: currentTexture.index, 
                isMirrored: currentTexture.isMirrored || false,
                type: currentTexture.type
            };
        }
        

        function createFluidSkybox() {
            
            // üéØ ƒ∞lk texture'lar zaten y√ºklendi - MASTER QUEUE'dan ilk texture'ƒ± kullan!
            currentUniverseIndex = masterUniverseQueue[0];
            // üì± Mobilde 2. texture hen√ºz yok olabilir - kendini kullan!
            nextUniverseIndex = (isMobile && !universeTextures[masterUniverseQueue[1]]) ? 
                masterUniverseQueue[0] : 
                masterUniverseQueue[1];
            
            // üì± ƒ∞lk pour texture
            currentPourIndex = masterPourQueue[0];

            const skyboxGeometry = new THREE.SphereGeometry(
                3000, 
                isMobile && !isTablet ? 
                    (screenSize <= 700 ? 32 : 40) :  // üì± K√º√ß√ºk: 32, B√ºy√ºk: 40
                    (isTablet ? 48 : 64),  // iPad: 48, Desktop: 64
                isMobile && !isTablet ? 
                    (screenSize <= 700 ? 32 : 40) : 
                    (isTablet ? 48 : 64)
            );
            
            fluidMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: universeTextures[currentUniverseIndex] },
                    uNextTexture: { value: universeTextures[nextUniverseIndex] },
                    uPourTexture: { value: pourTextures[currentPourIndex] },
                    uTime: { value: 0 },
                    uFlowSpeed: { value: flowSpeed },
                    uWaveAmplitude: { value: waveAmplitude },
                    uFluidIntensity: { value: fluidIntensity },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uTransition: { value: 1.0 },
                    uIsTransitioning: { value: false },
                    uMirrorMode: { value: 0.0 },
                    uColorTemp: { value: 1.0 },
                    uPourEffectIntensity: { value: isPhone ? 0.0 : 0.0 },  // ‚úÖ TELEFONDA POUR KAPALI!
                    uPourMirrorX: { value: false },  // ü™û Sola aynalama
                    uPourMirrorY: { value: false }   // ü™û √úste aynalama
                },
                vertexShader: fluidVertexShader,
                fragmentShader: fluidFragmentShader,
                side: THREE.BackSide
            });

            fluidSkybox = new THREE.Mesh(skyboxGeometry, fluidMaterial);
            scene.add(fluidSkybox);
            
            // üåå PROFESYONEL ENVIRONMENT MAP OLU≈ûTUR!
            updateEnvironmentMap();
            
            cycleStartTime = Date.now();
            lastSkyboxChange = Date.now();
            lastPourTextureChange = Date.now();
            
            // üì± Skybox y√ºklendi!
            assetsLoaded.skybox = true;
            checkAllLoaded();
        }
        
        // üåå Environment Map g√ºncelleme fonksiyonu
        function updateEnvironmentMap() {
            // ‚ùå KALDIRILDI! scene.environment araba rengini deƒüi≈ütiriyordu!
            // Artƒ±k sadece yol roadCubeCamera ile envMap kullanƒ±yor!
        }

        // üéØ AKILLI TEXTURE STREAMING - ƒ∞lerideki texture'larƒ± √∂nceden y√ºkle!
        // üéØ AKILLI TEXTURE STREAMING - ƒ∞lerideki texture'larƒ± √∂nceden y√ºkle!
        let lastPreloadTime = 0;
        function preloadUpcomingTextures() {
            if (!isMobile) return;
            if (isLoadingTexture) return;  // Zaten y√ºkleniyor!
            if (Date.now() - lastPreloadTime < 5000) return;  // 5 saniye bekle!
            
            lastPreloadTime = Date.now();
            
            // ≈ûu anki pozisyondan 2 texture ilerisi
            for (let i = 1; i <= PRELOAD_DISTANCE; i++) {
                const upcomingIndex = (universeQueuePosition + i) % masterUniverseQueue.length;
                const textureIndex = masterUniverseQueue[upcomingIndex];
                
                // Texture hen√ºz y√ºklenmediyse ve limit a≈üƒ±lmadƒ±ysa y√ºkle!
                if (!universeTextures[textureIndex] && activeTextureIndices.size < MAX_LOADED_TEXTURES - 1) {
                    loadUniverseTexture(textureIndex);
                    break;  // Bir kerede 1 tane y√ºkle!
                }
            }
        }
        
        function updateFluidSkybox() {
            if (!fluidMaterial) return;
            
            const currentTime = Date.now();
            const cycleTime = (currentTime - cycleStartTime) % CYCLE_DURATION;
            
            // üéØ STREAMING: Her d√∂ng√º ba≈üƒ±nda ilerideki texture'larƒ± y√ºkle!
            if (cycleTime < 1000 && isMobile) {
                preloadUpcomingTextures();
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // M√úKEMMEL D√ñNG√ú Sƒ∞STEMƒ∞
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // üé≤ Pour texture se√ßimi - Pool sisteminden! (‚úÖ TELEFONDA SKIP!)
            if (!isPhone && cycleTime < 100) {
                const pourData = getRandomPourIndex();  // { index, isMirrored, type }
                currentPourIndex = pourData.index;
                
                // üé® Pool sisteminden gelen texture tipine g√∂re kullan
                if (pourData.type === 'universe') {
                    // Universe texture'ƒ± pour olarak kullan!
                    if (universeTextures[currentPourIndex]) {
                        fluidMaterial.uniforms.uPourTexture.value = universeTextures[currentPourIndex];
                        // Universe'de mirroring yok
                        fluidMaterial.uniforms.uPourMirrorX.value = false;
                        fluidMaterial.uniforms.uPourMirrorY.value = false;
                    }
                } else {
                    // Pour texture kullan (normal veya mirrored)
                    if (pourTextures[currentPourIndex]) {
                        fluidMaterial.uniforms.uPourTexture.value = pourTextures[currentPourIndex];
                        // ü™û Mirroring uygula - sola VE √ºste!
                        fluidMaterial.uniforms.uPourMirrorX.value = pourData.isMirrored;
                        fluidMaterial.uniforms.uPourMirrorY.value = pourData.isMirrored;
                    }
                }
            }
            
            // ‚úÖ TELEFONDA POUR Hƒ∞√á ZAMAN A√áILMASIN!
            if (isPhone) {
                pourEffectIntensity = 0.0;
                waveEffectIntensity = 0.0;
                fluidMaterial.uniforms.uWaveAmplitude.value = 0.0;
                fluidMaterial.uniforms.uFluidIntensity.value = 0.0;
            } else if (cycleTime < PURE_SPACE_DURATION) {
                // Bu if artƒ±k √ßalƒ±≈ümaz √ß√ºnk√º PURE_SPACE_DURATION = 0
                // Ama kod uyumluluƒüu i√ßin bƒ±rakƒ±yorum
                pourEffectIntensity = 0.0;
                waveEffectIntensity = 0.0;
                fluidMaterial.uniforms.uWaveAmplitude.value = 0.0;
                fluidMaterial.uniforms.uFluidIntensity.value = 0.0;
                
            } else if (cycleTime < POUR_FADE_IN_START + POUR_FADE_IN_DURATION) {
                // ‚ñ∂ 10-20s: POUR + WAVE FADE IN
                const fadeProgress = (cycleTime - POUR_FADE_IN_START) / POUR_FADE_IN_DURATION;
                const smoothProgress = 0.5 - 0.5 * Math.cos(fadeProgress * Math.PI); // Sine easing
                
                pourEffectIntensity = smoothProgress;
                waveEffectIntensity = smoothProgress;
                
                fluidMaterial.uniforms.uWaveAmplitude.value = waveAmplitude * smoothProgress;
                fluidMaterial.uniforms.uFluidIntensity.value = fluidIntensity * smoothProgress;
                
            } else if (cycleTime < POUR_FADE_IN_START + POUR_FADE_IN_DURATION + POUR_FULL_DURATION) {
                // ‚ñ∂ 20-25s: POUR + WAVE TAM G√ñR√úN√úR
                pourEffectIntensity = 1.0;
                waveEffectIntensity = 1.0;
                
                fluidMaterial.uniforms.uWaveAmplitude.value = waveAmplitude;
                fluidMaterial.uniforms.uFluidIntensity.value = fluidIntensity;
                
            } else if (cycleTime < POUR_FADE_OUT_START + POUR_FADE_OUT_DURATION) {
                // ‚ñ∂ 25-35s: POUR FADE OUT + SPACE BLEND (PARALEL)
                const fadeProgress = (cycleTime - POUR_FADE_OUT_START) / POUR_FADE_OUT_DURATION;
                const smoothProgress = 0.5 - 0.5 * Math.cos(fadeProgress * Math.PI); // Sine easing
                
                // Pour ve wave geri √ßekiliyor (AYNI pour texture)
                pourEffectIntensity = 1.0 - smoothProgress;
                waveEffectIntensity = 1.0 - smoothProgress;
                
                fluidMaterial.uniforms.uWaveAmplitude.value = waveAmplitude * (1.0 - smoothProgress);
                fluidMaterial.uniforms.uFluidIntensity.value = fluidIntensity * (1.0 - smoothProgress);
                
                // Space blend ba≈ülatma (ilk kez - sadece bir kez √ßalƒ±≈üsƒ±n)
                if (fadeProgress < 0.01 && !fluidMaterial.uniforms.uIsTransitioning.value) {
                    // Sadece y√ºklenmi≈ü texture'larƒ± kullan!
                    do {
                        nextUniverseIndex = getRandomUniverseIndex();
                    } while (nextUniverseIndex === currentUniverseIndex && loadedUniverseCount > 1);
                    
                    // Texture y√ºklenmi≈üse kullan
                    if (universeTextures[nextUniverseIndex]) {
                        fluidMaterial.uniforms.uNextTexture.value = universeTextures[nextUniverseIndex];
                        fluidMaterial.uniforms.uIsTransitioning.value = true;
                    }
                }
                
                // Space blend progress (0 ‚Üí 1: eski space'den yeni space'e)
                // Shader'da transition mantƒ±ƒüƒ±na g√∂re ayarla
                fluidMaterial.uniforms.uTransition.value = 1.0 - smoothProgress;
                
                // Transition tamamlandƒ± mƒ±? Hemen yeni d√∂ng√º!
                if (smoothProgress >= 0.99) {
                    currentUniverseIndex = nextUniverseIndex;
                    fluidMaterial.uniforms.uTexture.value = universeTextures[currentUniverseIndex];
                    fluidMaterial.uniforms.uIsTransitioning.value = false;
                    
                    // üåå ENVIRONMENT MAP G√úNCELLE!
                    updateEnvironmentMap();
                }
            }
            
            // D√∂ng√º sƒ±fƒ±rlama (40. saniyede - yeni space = yeni pour!)
            if (cycleTime >= CYCLE_DURATION - 100 && cycleTime < CYCLE_DURATION) {
                cycleStartTime = currentTime;
            }
            
            // Wave animasyonu (sadece aktif olduƒüunda)
            if (waveEffectIntensity > 0) {
                fluidTime += 0.016 * 0.25;
                fluidMaterial.uniforms.uTime.value = fluidTime;
                fluidMaterial.uniforms.uFlowSpeed.value = flowSpeed;
            }
            
            fluidMaterial.uniforms.uPourEffectIntensity.value = pourEffectIntensity;
        }
        // ============ YENƒ∞ KISIM Bƒ∞TTƒ∞ - A≈ûAƒûISI ORJƒ∞NAL ============

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.714);
        scene.add(ambientLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444466, 0.816);
        hemiLight.position.set(0, 300, 0);
        scene.add(hemiLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 3.0);
        mainLight.position.set(200, 250, 200);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = isMobile ? 4096 : 8192;  // üéØ 2048‚Üí4096 (mobil), 4096‚Üí8192 (desktop) ULTRA!
        mainLight.shadow.mapSize.height = isMobile ? 4096 : 8192;
        mainLight.shadow.camera.far = 1000;
        mainLight.shadow.camera.left = -250;
        mainLight.shadow.camera.right = 250;
        mainLight.shadow.camera.top = 250;
        mainLight.shadow.camera.bottom = -250;
        mainLight.shadow.bias = -0.00001;  // üéØ -0.0001 ‚Üí -0.00001 (Daha hassas - √ßizgi yok!)
        mainLight.shadow.normalBias = 0.05;  // üéØ 0.02 ‚Üí 0.05 (Daha g√º√ßl√º - artifact yok!)
        mainLight.shadow.radius = 2;  // üéØ Yumu≈üak kenarlar!
        scene.add(mainLight);

        // üì± MOBƒ∞L: 2 ƒ±≈üƒ±k yeterli! (4 yerine)
        if (!isMobile) {
            const roadLight1 = new THREE.DirectionalLight(0xffffff, 1.5);
            roadLight1.position.set(-200, 200, 0);
            scene.add(roadLight1);

            const roadLight2 = new THREE.DirectionalLight(0xffffff, 1.5);
            roadLight2.position.set(200, 200, 0);
            scene.add(roadLight2);
        }

        const roadLight3 = new THREE.DirectionalLight(0xffffff, 1.2);
        roadLight3.position.set(0, 200, 200);
        scene.add(roadLight3);

        const roadLight4 = new THREE.DirectionalLight(0xffffff, 1.2);
        roadLight4.position.set(0, 200, -200);
        scene.add(roadLight4);

        const fillLight1 = new THREE.DirectionalLight(0xaaccff, 0.408);
        fillLight1.position.set(-200, 150, -200);
        scene.add(fillLight1);

        const fillLight2 = new THREE.DirectionalLight(0xffccaa, 0.306);
        fillLight2.position.set(200, 150, -200);
        scene.add(fillLight2);

        const spotLight = new THREE.SpotLight(0xffffff, 1.224);
        spotLight.angle = Math.PI / 5;
        spotLight.penumbra = 0.3;
        spotLight.distance = 120;
        spotLight.castShadow = false;  // Shadow KAPALI!
        
        scene.add(spotLight);

        let car = null;
        const keys = {};
        let carSpeed = 0;
        let maxSpeed = 0.367;  // 0.34 ‚Üí 0.367 (%8 artƒ±rƒ±ldƒ±!)
        let acceleration = 0.00734;  // 0.0068 ‚Üí 0.00734 (%8 artƒ±rƒ±ldƒ±!)
        let deceleration = 0.006;
        let turnSpeed = 0;
        let maxTurnSpeed = 0.02;
        
        let cameraMode = 0;
        
        const DEFAULT_CAMERA_SETTINGS = {
            mode0: {
                yaw: 0,
                pitch: -0.1,
                distance: 19.6,
                fov: 75
            },
            mode1: {
                pitch: 0,
                yaw: 0,
                distance: 0,
                fov: 75
            },
            mode2: {
                theta: 0,
                phi: Math.PI / 6,
                radius: 150,
                fov: 75
            }
        };
        
        let cameraYaw = DEFAULT_CAMERA_SETTINGS.mode0.yaw;
        let cameraPitch = DEFAULT_CAMERA_SETTINGS.mode0.pitch;
        let cameraDistance = DEFAULT_CAMERA_SETTINGS.mode0.distance;
        let cameraRadius = DEFAULT_CAMERA_SETTINGS.mode2.radius;
        let cameraTheta = DEFAULT_CAMERA_SETTINGS.mode2.theta;
        let cameraPhi = DEFAULT_CAMERA_SETTINGS.mode2.phi;
        
        let targetCameraPosition = new THREE.Vector3();
        let currentCameraPosition = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();
        let currentLookAt = new THREE.Vector3();
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        
        let smoothCarPosition = new THREE.Vector3();
        let smoothCarRotation = 0;
        let smoothCarHeight = 0;
        let targetCarHeight = 0;
        let heightVelocity = 0;
        let smoothCarPitch = 0;
        let smoothCarRoll = 0;
        let previousRoadHeight = 0;
        let roadHeightVelocity = 0;
        
        let lastCheckpointT = 0;
        let lastCheckpointPoint = null;
        let checkpointSearchCooldown = 0;
        
        let roadPullAccumulator = new THREE.Vector2(0, 0);
        let lastRoadDistance = 0;
        
        let heightBuffer = [];
        const heightBufferSize = 8;
        
        let smoothedTargetHeight = 0;
        let ultraSmoothHeight = 0;

        let trackMesh = null;
        let pathCurve = null;
        let checkpoints = [];
        const roadScale = 4.0;
        
        let mirrorMixers = [];
        let rotatingMirrors = [];
        let mirrorMeshes = [];
        let mirrorsLoaded = 0;
        let mirrorsCreated = 0;
        const TOTAL_MIRRORS = isMobile ? 40 : 58;  // üì± Mobilde 40 ayna - hala √ßok g√ºzel!

        const roadData = {
            "version": "10.0",
            "metadata": {
                "totalPoints": 30,
                "checkpointCount": 30,
                "closed": true,
                "precision": "2mm",
                "hasCheckpointSizes": true
            },
            "checkpoints": [
                {"id": 1, "position": {"x": -25.646, "y": 0.163, "z": 4.058}, "width": 3},
                {"id": 2, "position": {"x": -26.155, "y": 0.181, "z": -1.127}, "width": 3},
                {"id": 3, "position": {"x": -24.894, "y": 0.148, "z": -6.112}, "width": 3},
                {"id": 4, "position": {"x": -21.683, "y": 0.149, "z": -9.789}, "width": 3},
                {"id": 5, "position": {"x": -16.726, "y": 0.157, "z": -11.967}, "width": 3},
                {"id": 6, "position": {"x": -11.452, "y": 0.17, "z": -11.642}, "width": 3},
                {"id": 7, "position": {"x": -6.245, "y": 0.169, "z": -9.035}, "width": 3},
                {"id": 8, "position": {"x": -2.991, "y": 0.174, "z": -4.223}, "width": 3},
                {"id": 9, "position": {"x": 0.854, "y": 0.176, "z": 0.94}, "width": 3},
                {"id": 10, "position": {"x": 3.971, "y": 0.17, "z": 6.291}, "width": 3},
                {"id": 11, "position": {"x": 8.197, "y": 0.171, "z": 10.269}, "width": 3},
                {"id": 12, "position": {"x": 13.561, "y": 0.178, "z": 11.828}, "width": 3},
                {"id": 13, "position": {"x": 19.141, "y": 0.169, "z": 10.994}, "width": 3},
                {"id": 14, "position": {"x": 23.726, "y": 0.154, "z": 7.705}, "width": 3},
                {"id": 15, "position": {"x": 26.162, "y": 0.158, "z": 2.519}, "width": 3},
                {"id": 16, "position": {"x": 25.602, "y": 0.203, "z": -3.421}, "width": 3},
                {"id": 17, "position": {"x": 23.067, "y": 0.14, "z": -8.491}, "width": 3},
                {"id": 18, "position": {"x": 17.356, "y": 0.57, "z": -11.475}, "width": 3},
                {"id": 19, "position": {"x": 12.709, "y": 1.332, "z": -12.195}, "width": 3},
                {"id": 20, "position": {"x": 9.282, "y": 2.084, "z": -11.272}, "width": 3},
                {"id": 21, "position": {"x": 5.431, "y": 3.035, "z": -8.736}, "width": 3},
                {"id": 22, "position": {"x": 3.409, "y": 3.558, "z": -5.457}, "width": 3},
                {"id": 23, "position": {"x": 1.394, "y": 3.785, "z": -1.957}, "width": 3},
                {"id": 24, "position": {"x": -0.665, "y": 3.841, "z": 1.429}, "width": 3},
                {"id": 25, "position": {"x": -3.825, "y": 3.595, "z": 5.443}, "width": 3},
                {"id": 26, "position": {"x": -8.47, "y": 2.557, "z": 9.753}, "width": 3},
                {"id": 27, "position": {"x": -14.626, "y": 1.111, "z": 12.027}, "width": 3},
                {"id": 28, "position": {"x": -19.934, "y": 0.371, "z": 10.023}, "width": 3},
                {"id": 29, "position": {"x": -23.961, "y": 0.136, "z": 7.489}, "width": 3},
                {"id": 30, "position": {"x": -25.674, "y": 0.163, "z": 3.981}, "width": 3}
            ]
        };

        function createCar() {
            const carGroup = new THREE.Group();
            
            const carLoader = new THREE.GLTFLoader();
            carLoader.load(
                'https://busrasuhaydar.github.io/araba/araba.glb',
                function(gltf) {
                    const carModel = gltf.scene;
                    
                    carModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    const box = new THREE.Box3().setFromObject(carModel);
                    const size = box.getSize(new THREE.Vector3());
                    
                    const targetHeight = 2.5;
                    const targetLength = 5;
                    const scaleY = targetHeight / size.y;
                    const scaleZ = targetLength / size.z;
                    const finalScale = Math.max(scaleY, scaleZ);
                    
                    
                    carModel.position.set(0, 0, 0);
                    carModel.rotation.y = Math.PI;
                    carModel.scale.set(finalScale, finalScale, finalScale);
                    
                    carGroup.add(carModel);
                    
                    // üì± Araba y√ºklendi!
                    assetsLoaded.car = true;
                    checkAllLoaded();
                },
                function(xhr) {
                },
                function(error) {
                    
                    const carBody = new THREE.Mesh(
                        new THREE.BoxGeometry(2.5, 1.2, 5),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xFF1100,
                            shininess: 180,
                            specular: 0xaaaaaa,
                            emissive: 0x440000,
                            emissiveIntensity: 0.3
                        })
                    );
                    carBody.position.y = 1;
                    carBody.castShadow = true;
                    carGroup.add(carBody);
                    
                    // üì± Fallback araba da y√ºklendi sayƒ±lƒ±r!
                    assetsLoaded.car = true;
                    checkAllLoaded();
                }
            );

            const headlightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const headlightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 1.5,
                transparent: true,
                opacity: 0
            });
            
            [-0.9, 0.9].forEach(x => {
                const light = new THREE.Mesh(headlightGeometry, headlightMaterial);
                light.position.set(x, 0.9, 2.6);
                carGroup.add(light);
                
                const carSpotLight = new THREE.SpotLight(0xFFFFFF, 2.5);
                carSpotLight.angle = Math.PI / 4;
                carSpotLight.penumbra = 0.4;
                carSpotLight.distance = 100;
                carSpotLight.decay = 2;
                carSpotLight.position.set(x, 0.9, 2.6);
                carSpotLight.target.position.set(x, -0.5, 20);
                carGroup.add(carSpotLight);
                carGroup.add(carSpotLight.target);
            });

            car = carGroup;
            
            if (checkpoints && checkpoints.length > 0) {
                const startCheckpoint = checkpoints[0];
                const startHeight = startCheckpoint.y + 0.25;  // üéØ 0.25 offset ile uyumlu!
                
                car.position.set(
                    startCheckpoint.x - 3,  // 3 birim SOLA!
                    startHeight,
                    startCheckpoint.z - 10  // 5+5=10 birim GERƒ∞!
                );
                smoothCarPosition.copy(car.position);
                smoothCarHeight = startHeight;
                smoothedTargetHeight = startHeight;
                ultraSmoothHeight = startHeight;
                previousRoadHeight = startCheckpoint.y;
                
                for (let i = 0; i < heightBufferSize; i++) {
                    heightBuffer.push(startCheckpoint.y);
                }
            }
            
            scene.add(carGroup);
        }

        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://busrasuhaydar.github.io/sonsuzyol/sonsuzracee.glb',
            function(gltf) {
                trackMesh = gltf.scene;
                trackMesh.position.set(0, 0, 0);
                trackMesh.scale.set(roadScale, roadScale, roadScale);
                
                trackMesh.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // üèéÔ∏è ARABA mƒ± YOL mu kontrol et!
                        
                        // Araba ve ayna HARƒ∞√á her ≈üey YOL!
                        const isCar = child.name.toLowerCase().includes('car') || 
                                     child.name.toLowerCase().includes('vehicle') ||
                                     child.name.toLowerCase().includes('infinity');
                        
                        const isMirror = child.name.toLowerCase().includes('mirror') ||
                                        child.name.toLowerCase().includes('ayna');
                        
                        const isRoad = !isCar && !isMirror;  // Araba ve ayna deƒüilse YOL!
                        
                        
                        if (child.material) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(mat => {
                                
                                if (isRoad) {
                                    // üõ£Ô∏è YOL - KOYU GRƒ∞ AYNA Gƒ∞Bƒ∞ METALƒ∞K!
                                    // üì± Telefonda daha a√ßƒ±k koyu gri (daha g√∂r√ºn√ºr!)
                                    mat.color = new THREE.Color(isPhone ? 0x3a3a3a : 0x2d2d2d);  // ‚ö´ Telefonda biraz daha a√ßƒ±k!
                                    mat.metalness = 1.0;  // TAM METALƒ∞K!
                                    mat.roughness = 0.0;  // SIFIR roughness = tam ayna!
                                    mat.reflectivity = 1.0;  // Maksimum yansƒ±ma!
                                    
                                    if (!isPhone && roadCubeRenderTarget) {
                                        // ‚úÖ TABLET/DESKTOP: Skybox yansƒ±masƒ± - AYNA!
                                        mat.envMap = roadCubeRenderTarget.texture;
                                        mat.envMapIntensity = 2.0;  // G√º√ßl√º yansƒ±ma!
                                    } else {
                                        // ‚úÖ TELEFON: envMap yok ama TAM METALƒ∞K ve KOYU GRƒ∞!
                                        mat.envMap = null;
                                        mat.envMapIntensity = 0;
                                    }
                                    
                                } else {
                                    // üèéÔ∏è ARABA - NORMAL BOYALI Y√úZEY, METALLƒ∞K YOK!
                                    mat.metalness = 0.0;  // 1.0 ‚Üí 0.0 METALLƒ∞K KAPALI!
                                    mat.roughness = 0.5;  // Normal boyalƒ± y√ºzey
                                    
                                    // ‚ùå envMap YOK!
                                    mat.envMap = null;
                                    mat.envMapIntensity = 0;
                                    
                                    // Clearcoat yok
                                    mat.clearcoat = 0;
                                    mat.clearcoatRoughness = 0;
                                    
                                    // IOR ve reflectivity de sƒ±fƒ±rla
                                    mat.reflectivity = 0;
                                    
                                }
                                
                                const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                                
                                if (mat.map) {
                                    mat.map.anisotropy = maxAnisotropy;
                                    mat.map.minFilter = THREE.LinearMipmapLinearFilter;
                                    mat.map.magFilter = THREE.LinearFilter;
                                    mat.map.wrapS = THREE.RepeatWrapping;
                                    mat.map.wrapT = THREE.RepeatWrapping;
                                    mat.map.encoding = THREE.sRGBEncoding;
                                    mat.map.needsUpdate = true;
                                }
                                if (mat.normalMap) {
                                    mat.normalMap.anisotropy = maxAnisotropy;
                                    mat.normalMap.minFilter = THREE.LinearMipmapLinearFilter;
                                    mat.normalMap.magFilter = THREE.LinearFilter;
                                    mat.normalMap.needsUpdate = true;
                                }
                                if (mat.roughnessMap) {
                                    mat.roughnessMap.anisotropy = maxAnisotropy;
                                    mat.roughnessMap.minFilter = THREE.LinearMipmapLinearFilter;
                                    mat.roughnessMap.magFilter = THREE.LinearFilter;
                                    mat.roughnessMap.needsUpdate = true;
                                }
                                if (mat.metalnessMap) {
                                    mat.metalnessMap.anisotropy = maxAnisotropy;
                                    mat.metalnessMap.minFilter = THREE.LinearMipmapLinearFilter;
                                    mat.metalnessMap.magFilter = THREE.LinearFilter;
                                    mat.metalnessMap.needsUpdate = true;
                                }
                                if (mat.aoMap) {
                                    mat.aoMap.anisotropy = maxAnisotropy;
                                    mat.aoMap.minFilter = THREE.LinearMipmapLinearFilter;
                                    mat.aoMap.magFilter = THREE.LinearFilter;
                                    mat.aoMap.needsUpdate = true;
                                }
                                if (mat.emissiveMap) {
                                    mat.emissiveMap.anisotropy = maxAnisotropy;
                                    mat.emissiveMap.minFilter = THREE.LinearMipmapLinearFilter;
                                    mat.emissiveMap.magFilter = THREE.LinearFilter;
                                    mat.emissiveMap.needsUpdate = true;
                                }
                                
                                mat.needsUpdate = true;
                            });
                        }
                    }
                });
                
                scene.add(trackMesh);
                createPath();
                createCar();
                createMirrors();
                setupControls();
                
                // üì± Track y√ºklendi!
                assetsLoaded.track = true;
                checkAllLoaded();
            },
            (xhr) => {
                const percent = Math.round(xhr.loaded / xhr.total * 100);
                document.getElementById('loading').innerHTML = 'Welcome to Su Su Land!<br>ARE YOU READY?<br><br>' + percent + '%';
            },
            (error) => {
                document.getElementById('loading').innerHTML = 'Welcome to Su Su Land!<br>Loading Error...';
                // üì± Hata olsa bile devam edelim
                assetsLoaded.track = true;
                checkAllLoaded();
            }
        );

        function createPath() {
            checkpoints = roadData.checkpoints.map(cp => 
                new THREE.Vector3(
                    cp.position.x * roadScale, 
                    cp.position.y * roadScale, 
                    cp.position.z * roadScale
                )
            );

            const points = [];
            for (let i = 0; i < checkpoints.length; i++) {
                const cp1 = checkpoints[i];
                const cp2 = checkpoints[(i + 1) % checkpoints.length];
                const dist = cp1.distanceTo(cp2);
                const heightDiff = Math.abs(cp2.y - cp1.y);
                
                const baseSegments = Math.max(100, Math.floor(dist / 0.1));
                const heightBonus = Math.floor(heightDiff * 30);
                const segments = baseSegments + heightBonus;
                
                for (let j = 0; j < segments; j++) {
                    const t = j / segments;
                    const point = new THREE.Vector3().lerpVectors(cp1, cp2, t);
                    points.push(point);
                }
            }

            pathCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.002);
        }

        function createMirrors() {
            const mirrorLoader = new THREE.GLTFLoader();
            
            // üé® MANUEL SATIRLANDIRMA - HER C√úMLE √ñZEL OLARAK HAZIRLANMI≈û!
            function getManualLines(text) {
                // HER C√úMLE ƒ∞√áƒ∞N MANUEL SATIRLANDIRMA
                const manualLayouts = {
                    // √ñN Y√úZ
                    "Which voice isn't my inner voice?": ["Which voice", "isn't my inner voice", "?"],
                    "WHO I AM?": ["WHO", "I AM", "?"],
                    "Is it the me in the mirror driving the car, or the shadow inside me?": ["Is it the me in the mirror", "driving the car,", "or the shadow", "inside me", "?"],
                    "When someone finally understands me, will I still be the same me?": ["When someone", "finally understands me,", "will I still be", "the same me", "?"],
                    "How many times have I deceived my heart with my mind?": ["How many times", "have I deceived", "my heart", "with my mind", "?"],
                    "To whom do I owe an apology?": ["To whom", "do I owe", "an apology", "?"],
                    "Whose expectation has held my steering wheel?": ["Whose expectation", "has held my", "steering wheel", "?"],
                    "Who should I call more often while I still can?": ["Who should I call", "more often", "while I still can", "?"],
                    "What am I truly feeling right now?": ["What am I", "truly feeling", "right now", "?"],
                    "Which boundary did I actually draw myself?": ["Which boundary", "did I actually", "draw myself", "?"],
                    "Which burden should I have already let go of?": ["Which burden", "should I have already", "let go of", "?"],
                    "Which small victory did I forget to celebrate?": ["Which small victory", "did I forget", "to celebrate", "?"],
                    "Are \"road lines\" there to keep me inside an illusion?": ["Are \"road lines\" there", "to keep me inside", "an illusion", "?"],
                    "Was it braver to run away or to stay?": ["Was it braver", "to run away", "or to stay", "?"],
                    "How many times did I say the wrong things to the right person?": ["How many times", "did I say the wrong things", "to the right person", "?"],
                    "Why am I here?": ["Why", "am I here", "?"],
                    "Which color am I?": ["Which color", "am I", "?"],
                    "If I took off my mask, who would be underneath?": ["If I took off my mask,", "who would be", "underneath", "?"],
                    "Do I have to get lost to be found?": ["Do I have to", "get lost", "to be found", "?"],
                    "Is the child inside me still speaking?": ["Is the child", "inside me", "still speaking", "?"],
                    "Why are the answers to my questions always new questions?": ["Why are the answers", "to my questions", "always new questions", "?"],
                    "Who am I looking for when I look in the mirror?": ["Who am I looking for", "when I look", "in the mirror", "?"],
                    "Which moment did I save for eternity but never lived?": ["Which moment", "did I save for eternity", "but never lived", "?"],
                    "Can I forgive myself?": ["Can I", "forgive myself", "?"],
                    "Is not choosing also a choice?": ["Is not choosing", "also a choice", "?"],
                    "If I went back, would I walk the same road again?": ["If I went back,", "would I walk", "the same road again", "?"],
                    "If I could change one thing, what would it be?": ["If I could change", "one thing,", "what would it be", "?"],
                    "What would have happened if I had said 'YES'?": ["What would have happened", "if I had said", "'YES'", "?"],
                    "How many times have I wished upon the same star?": ["How many times", "have I wished upon", "the same star", "?"],
                    "When did I lie to myself?": ["When did I", "lie to myself", "?"],
                    "Which truth, if I accepted it, would set me free?": ["Which truth,", "if I accepted it,", "would set me free", "?"],
                    "When will the white doves fly for us in the sky?": ["When will the", "white doves fly", "for us in the sky", "?"],
                    "How many times have I been reborn? Sometimes without even realizing?": ["How many times", "have I been reborn", "?", "Sometimes without", "even realizing", "?"],
                    "Is it harder to forgive or to forget?": ["Is it harder", "to forgive", "or to forget", "?"],
                    "Is it really possible for someone to truly know me?": ["Is it really possible", "for someone", "to truly know me", "?"],
                    "If my childhood self sat in the passenger seat, where would I take them?": ["If my childhood self", "sat in the passenger seat,", "where would I", "take them", "?"],
                    "Does \"the right time\" really exist?": ["Does \"the right time\"", "really exist", "?"],
                    "When will it rain?": ["When", "will it rain", "?"],
                    "Too much, or too little?": ["Too much,", "or too little", "?"],
                    "Should it be blue or orange?": ["Should it be", "blue", "or orange", "?"],
                    "Does the life I didn't choose, miss me?": ["Does the life", "I didn't choose,", "miss me", "?"],
                    "If my emotions were a museum, which piece would be the most broken?": ["If my emotions", "were a museum,", "which piece would be", "the most broken", "?"],
                    "What would change if I weren't afraid?": ["What would change", "if I weren't", "afraid", "?"],
                    "What should I eat today?": ["What should I", "eat today", "?"],
                    "Who would I be if I lived in an era without technology?": ["Who would I be", "if I lived in an era", "without technology", "?"],
                    "What does \"normal\" even mean?": ["What does", "\"normal\"", "even mean", "?"],
                    "What if the universe is leaving me small clues and I just don't notice them?": ["What if the universe", "is leaving me small clues", "and I just don't", "notice them", "?"],
                    "If I had a magic wand, what's the first thing I'd change?": ["If I had a magic wand,", "what's the first thing", "I'd change", "?"],
                    "Where is my home ‚Äî my true home?": ["Where is my home", "‚Äî", "my true home", "?"],
                    "If I found a time machine, which date would I choose?": ["If I found", "a time machine,", "which date would", "I choose", "?"],
                    "Why haven't they invited me to give a TEDx talk yet?!": ["Why haven't they", "invited me to give", "a TEDx talk yet", "?!"],
                    "When will I find the courage to face my greatest fear?": ["When will I find", "the courage to face", "my greatest fear", "?"],
                    "Do I know where I'm going?": ["Do I know", "where I'm going", "?"],
                    "What truly makes me happy?": ["What truly", "makes me happy", "?"],
                    "Who's ready to dance with my soul?": ["Who's ready", "to dance", "with my soul", "?"],
                    "Is the night dark ‚Äî or am I the one left in the dark?": ["Is the night dark", "‚Äî", "or am I the one", "left in the dark", "?"],
                    "Am I still innocent?": ["Am I", "still innocent", "?"],
                    "Will all wars end one day?": ["Will all wars", "end one day", "?"],
                    
                    // ARKA Y√úZ
                    "Do I want to be invisible, or too visible?": ["Do I want", "to be invisible,", "or too visible", "?"],
                    "LESS is more?": ["LESS", "is more", "?"],
                    "Is this a grail?": ["Is this", "a grail", "?"],
                    "Could I belong to a place I've never been before?": ["Could I belong", "to a place", "I've never been before", "?"],
                    "When was the last time I wasn't trying to catch up with something?": ["When was the last time", "I wasn't trying", "to catch up", "with something", "?"],
                    "Could what makes me who I am be a moment I never actually lived?": ["Could what makes me", "who I am", "be a moment", "I never actually lived", "?"],
                    "What song is playing in the background of my life?": ["What song is playing", "in the background", "of my life", "?"],
                    "The things I thought were my fault ‚Äî did they really come from me?": ["The things I thought", "were my fault", "‚Äî", "did they really", "come from me", "?"],
                    "What if the path I chose is the wrong one?": ["What if the path", "I chose", "is the wrong one", "?"],
                    "Is this running away from uncertainty, or trying to take control?": ["Is this running away", "from uncertainty,", "or trying to", "take control", "?"],
                    "What if I don't decide now, and the chance slips away?": ["What if I don't", "decide now,", "and the chance", "slips away", "?"],
                    "Every \"yes\" or \"no\" I couldn't say ‚Äî what emptiness did it create inside me?": ["Every \"yes\" or \"no\"", "I couldn't say", "‚Äî", "what emptiness", "did it create", "inside me", "?"],
                    "How much did I do out of my own will, and how much out of others' expectations?": ["How much did I do", "out of my own will,", "and how much out of", "others' expectations", "?"],
                    "Which new path would make me more of who I am?": ["Which new path", "would make me", "more of who I am", "?"],
                    "Am I more afraid of being rejected or of being misunderstood?": ["Am I more afraid", "of being rejected", "or of being", "misunderstood", "?"],
                    "Is there such a thing as the right choice?": ["Is there such a thing", "as the right choice", "?"],
                    "With every breath, do we die a little, or are we born a little?": ["With every breath,", "do we die a little,", "or are we born", "a little", "?"],
                    "What was I really afraid of?": ["What was I", "really afraid of", "?"],
                    "Who did I see the last time I looked in the mirror?": ["Who did I see", "the last time", "I looked in the mirror", "?"],
                    "Which unsaid sentence still echoes inside me?": ["Which unsaid sentence", "still echoes", "inside me", "?"],
                    "Where does infinity begin?": ["Where does", "infinity", "begin", "?"],
                    "When was the last time I was truly in the present?": ["When was the last time", "I was truly", "in the present", "?"],
                    "What is death?": ["What is", "death", "?"],
                    "What is life?": ["What is", "life", "?"],
                    "What question am I the answer to?": ["What question", "am I the answer to", "?"],
                    "Will we meet in heaven?": ["Will we meet", "in heaven", "?"],
                    "Who stole my light?": ["Who stole", "my light", "?"],
                    "Where could the other sock be that I couldn't find the other day?": ["Where could", "the other sock be", "that I couldn't find", "the other day", "?"],
                    "How many times have I risen from my ashes like a phoenix?": ["How many times", "have I risen", "from my ashes", "like a phoenix", "?"],
                    "What will fill this void?": ["What will fill", "this void", "?"],
                    "Is what I see real or is it a dream?": ["Is what I see", "real", "or is it a dream", "?"],
                    "In my fight with the past, will I ever be proven right?": ["In my fight", "with the past,", "will I ever be", "proven right", "?"],
                    "Why am I crying? Why can't I cry?": ["Why am I crying", "?", "Why can't I cry", "?"],
                    "Is ownership a digital echo of existence?": ["Is ownership", "a digital echo", "of existence", "?"],
                    "Which NFT I own is the artist's attempt at immortality?": ["Which NFT I own", "is the artist's attempt", "at immortality", "?"],
                    "Which pieces in my collection do I keep not in my home or my wallet, but in my heart?": ["Which pieces", "in my collection", "do I keep not", "in my home or my wallet,", "but in my heart", "?"],
                    "Does infinite access diminish meaning?": ["Does infinite access", "diminish meaning", "?"],
                    "While searching for a 'Grail' piece, what absence am I truly seeking?": ["While searching", "for a 'Grail' piece,", "what absence", "am I truly seeking", "?"],
                    "Does poetry name colors, or do colors give birth to poetry?": ["Does poetry", "name colors,", "or do colors", "give birth to poetry", "?"],
                    "With which color would I paint my favorite poem?": ["With which color", "would I paint", "my favorite poem", "?"],
                    "Does the value of art arise from its aesthetics or from its confession?": ["Does the value of art", "arise from its aesthetics", "or from", "its confession", "?"],
                    "Which brushstroke replaces a real dream?": ["Which brushstroke", "replaces", "a real dream", "?"],
                    "Is the vibration of colors a universal language or a personal scream?": ["Is the vibration", "of colors", "a universal language", "or a personal scream", "?"],
                    "Can an artwork of art ever truly be considered 'complete'?": ["Can an artwork of art", "ever truly be considered", "'complete'", "?"],
                    "Is art a form of rebellion, or a space of reconciliation?": ["Is art a form", "of rebellion,", "or a space", "of reconciliation", "?"],
                    "Who is ready to dance with my soul?": ["Who is ready", "to dance", "with my soul", "?"],
                    "Is the night dark, or am I the one left in darkness?": ["Is the night dark,", "or am I the one", "left in darkness", "?"],
                    "Why does a poisonous familiarity feel safer than a healthy unknown?": ["Why does", "a poisonous familiarity", "feel safer than", "a healthy unknown", "?"],
                    "Will this pain ever serve a purpose one day?": ["Will this pain", "ever serve a purpose", "one day", "?"],
                    "Do they love me for my own light, or because I can hold their shadows within me?": ["Do they love me", "for my own light,", "or because I can hold", "their shadows within me", "?"],
                    "Will I win?": ["Will I", "win", "?"],
                    "WHY?": ["WHY", "?"],
                    "HOW?": ["HOW", "?"],
                    "WHEN?": ["WHEN", "?"],
                    "What is the matrix ulan?": ["What is", "the matrix ulan", "?"]
                };
                
                return manualLayouts[text] || [text];
            }
            
            function createTextTexture(text, width = isMobile ? 1024 : 2048, height = isMobile ? 512 : 1024) {  // üì± Mobilde yarƒ± boyut!
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, width, height);
                
                const lines = getManualLines(text);
                const lineCount = lines.length;
                
                // Mƒ∞Nƒ∞MUM PADDING
                const paddingX = 1;
                const paddingY = 1;
                const usableWidth = width - (paddingX * 2);
                const usableHeight = height - (paddingY * 2);
                
                // üì± MOBƒ∞LDE YAZILARI B√úY√úT - 2X! + %10 EKSTRA B√úY√úTME!
                const mobileFontMultiplier = (isMobile && !isTablet) ? 2.2 : 1.1;  // ‚úÖ %10 daha b√ºy√ºk!
                
                // B√úY√úK BA≈ûLANGI√á FONTLARI - %10 DAHA B√úY√úK!
                let fontSize;
                if (lineCount <= 2) fontSize = 380 * mobileFontMultiplier;
                else if (lineCount <= 3) fontSize = 340 * mobileFontMultiplier;
                else if (lineCount <= 4) fontSize = 300 * mobileFontMultiplier;
                else if (lineCount <= 5) fontSize = 270 * mobileFontMultiplier;
                else if (lineCount <= 6) fontSize = 240 * mobileFontMultiplier;
                else if (lineCount <= 7) fontSize = 220 * mobileFontMultiplier;
                else if (lineCount <= 8) fontSize = 200 * mobileFontMultiplier;
                else if (lineCount <= 9) fontSize = 180 * mobileFontMultiplier;
                else if (lineCount <= 10) fontSize = 165 * mobileFontMultiplier;
                else fontSize = 150 * mobileFontMultiplier;
                
                const lineHeightMultiplier = 1.02; // Sƒ±kƒ±!
                
                // En uzun satƒ±rƒ± bul
                ctx.font = `bold ${fontSize}px Arial`;
                let maxLineWidth = 0;
                let longestLine = '';
                lines.forEach(line => {
                    const lineWidth = ctx.measureText(line).width;
                    if (lineWidth > maxLineWidth) {
                        maxLineWidth = lineWidth;
                        longestLine = line;
                    }
                });
                
                // GENƒ∞≈ûLƒ∞K KONTROL√ú - Dikkatli!
                while (maxLineWidth > usableWidth && fontSize > 50) {
                    fontSize -= 2;
                    ctx.font = `bold ${fontSize}px Arial`;
                    maxLineWidth = ctx.measureText(longestLine).width;
                }
                
                // Y√úKSEKLƒ∞K KONTROL√ú - Dikkatli!
                let lineHeight = fontSize * lineHeightMultiplier;
                let totalTextHeight = lineCount * lineHeight;
                
                while (totalTextHeight > usableHeight && fontSize > 50) {
                    fontSize -= 2;
                    lineHeight = fontSize * lineHeightMultiplier;
                    totalTextHeight = lineCount * lineHeight;
                }
                
                // Final ayarlar
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Satƒ±rlarƒ± dikey ortala ve yaz - paddingY kullan!
                const startY = paddingY + (usableHeight - totalTextHeight) / 2 + lineHeight / 2;
                
                lines.forEach((line, index) => {
                    const y = startY + (index * lineHeight);
                    ctx.fillText(line, width / 2, y);
                });
                
                // DEBUG
                
                // Texture olu≈ütur
                const texture = new THREE.CanvasTexture(canvas);
                texture.encoding = THREE.sRGBEncoding;
                texture.needsUpdate = true;
                
                return texture;
            }

            function createTextTextureBack(text) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const width = 2048;
                const height = 1024;
                canvas.width = width;
                canvas.height = height;
                ctx.clearRect(0, 0, width, height);
                
                const lines = getManualLines(text);
                const lineCount = lines.length;
                
                // Mƒ∞Nƒ∞MUM PADDING
                const paddingX = 1;
                const paddingY = 1;
                const usableWidth = width - (paddingX * 2);
                const usableHeight = height - (paddingY * 2);
                
                // üì± MOBƒ∞LDE YAZILARI B√úY√úT - 2X! + %10 EKSTRA B√úY√úTME!
                const mobileFontMultiplier = (isMobile && !isTablet) ? 2.2 : 1.1;  // ‚úÖ %10 daha b√ºy√ºk!
                
                // B√úY√úK BA≈ûLANGI√á FONTLARI - %10 DAHA B√úY√úK!
                let fontSize;
                if (lineCount <= 2) fontSize = 380 * mobileFontMultiplier;
                else if (lineCount <= 3) fontSize = 340 * mobileFontMultiplier;
                else if (lineCount <= 4) fontSize = 300 * mobileFontMultiplier;
                else if (lineCount <= 5) fontSize = 270 * mobileFontMultiplier;
                else if (lineCount <= 6) fontSize = 240 * mobileFontMultiplier;
                else if (lineCount <= 7) fontSize = 220 * mobileFontMultiplier;
                else if (lineCount <= 8) fontSize = 200 * mobileFontMultiplier;
                else if (lineCount <= 9) fontSize = 180 * mobileFontMultiplier;
                else if (lineCount <= 10) fontSize = 165 * mobileFontMultiplier;
                else fontSize = 150 * mobileFontMultiplier;
                
                const lineHeightMultiplier = 1.02;
                
                // En uzun satƒ±rƒ± bul
                ctx.font = `bold ${fontSize}px Arial`;
                let maxLineWidth = 0;
                let longestLine = '';
                lines.forEach(line => {
                    const lineWidth = ctx.measureText(line).width;
                    if (lineWidth > maxLineWidth) {
                        maxLineWidth = lineWidth;
                        longestLine = line;
                    }
                });
                
                // GENƒ∞≈ûLƒ∞K KONTROL√ú
                while (maxLineWidth > usableWidth && fontSize > 50) {
                    fontSize -= 2;
                    ctx.font = `bold ${fontSize}px Arial`;
                    maxLineWidth = ctx.measureText(longestLine).width;
                }
                
                // Y√úKSEKLƒ∞K KONTROL√ú
                let lineHeight = fontSize * lineHeightMultiplier;
                let totalTextHeight = lineCount * lineHeight;
                
                while (totalTextHeight > usableHeight && fontSize > 50) {
                    fontSize -= 2;
                    lineHeight = fontSize * lineHeightMultiplier;
                    totalTextHeight = lineCount * lineHeight;
                }
                
                // Yazƒ±yƒ± √ßiz
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const startY = paddingY + (usableHeight - totalTextHeight) / 2 + lineHeight / 2;
                
                lines.forEach((line, index) => {
                    const y = startY + (index * lineHeight);
                    ctx.fillText(line, width / 2, y);
                });
                
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.encoding = THREE.sRGBEncoding;
                texture.needsUpdate = true;
                
                return texture;
            }

            const mirrorQuestions = [
                "Which voice isn't my inner voice?",
                "WHO I AM?",
                "Is it the me in the mirror driving the car, or the shadow inside me?",
                "When someone finally understands me, will I still be the same me?",
                "How many times have I deceived my heart with my mind?",
                "To whom do I owe an apology?",
                "Whose expectation has held my steering wheel?",
                "Who should I call more often while I still can?",
                "What am I truly feeling right now?",
                "Which boundary did I actually draw myself?",
                "Which burden should I have already let go of?",
                "Which small victory did I forget to celebrate?",
                "Are \"road lines\" there to keep me inside an illusion?",
                "Was it braver to run away or to stay?",
                "How many times did I say the wrong things to the right person?",
                "Why am I here?",
                "Which color am I?",
                "If I took off my mask, who would be underneath?",
                "Do I have to get lost to be found?",
                "Is the child inside me still speaking?",
                "Why are the answers to my questions always new questions?",
                "Who am I looking for when I look in the mirror?",
                "Which moment did I save for eternity but never lived?",
                "Can I forgive myself?",
                "Is not choosing also a choice?",
                "If I went back, would I walk the same road again?",
                "If I could change one thing, what would it be?",
                "What would have happened if I had said 'YES'?",
                "How many times have I wished upon the same star?",
                "When did I lie to myself?",
                "Which truth, if I accepted it, would set me free?",
                "When will the white doves fly for us in the sky?",
                "How many times have I been reborn? Sometimes without even realizing?",
                "Is it harder to forgive or to forget?",
                "Is it really possible for someone to truly know me?",
                "If my childhood self sat in the passenger seat, where would I take them?",
                "Does \"the right time\" really exist?",
                "When will it rain?",
                "Too much, or too little?",
                "Should it be blue or orange?",
                "Does the life I didn't choose, miss me?",
                "If my emotions were a museum, which piece would be the most broken?",
                "What would change if I weren't afraid?",
                "What should I eat today?",
                "Who would I be if I lived in an era without technology?",
                "What does \"normal\" even mean?",
                "What if the universe is leaving me small clues and I just don't notice them?",
                "If I had a magic wand, what's the first thing I'd change?",
                "Where is my home ‚Äî my true home?",
                "If I found a time machine, which date would I choose?",
                "Why haven't they invited me to give a TEDx talk yet?!",
                "When will I find the courage to face my greatest fear?",
                "Do I know where I'm going?",
                "What truly makes me happy?",
                "Who's ready to dance with my soul?",
                "Is the night dark ‚Äî or am I the one left in the dark?",
                "Am I still innocent?",
                "Will all wars end one day?"
            ];
            
            const mirrorQuestionsBack = [
                "Do I want to be invisible, or too visible?",
                "LESS is more?",
                "Is this a grail?",
                "Could I belong to a place I've never been before?",
                "When was the last time I wasn't trying to catch up with something?",
                "Could what makes me who I am be a moment I never actually lived?",
                "What song is playing in the background of my life?",
                "The things I thought were my fault ‚Äî did they really come from me?",
                "What if the path I chose is the wrong one?",
                "Is this running away from uncertainty, or trying to take control?",
                "What if I don't decide now, and the chance slips away?",
                "Every \"yes\" or \"no\" I couldn't say ‚Äî what emptiness did it create inside me?",
                "How much did I do out of my own will, and how much out of others' expectations?",
                "Which new path would make me more of who I am?",
                "Am I more afraid of being rejected or of being misunderstood?",
                "If I went back, would I walk the same road again?",
                "Is there such a thing as the right choice?",
                "With every breath, do we die a little, or are we born a little?",
                "What was I really afraid of?",
                "Who did I see the last time I looked in the mirror?",
                "Which unsaid sentence still echoes inside me?",
                "Where does infinity begin?",
                "When was the last time I was truly in the present?",
                "Whose expectation has held my steering wheel?",
                "What is death?",
                "What is life?",
                "What question am I the answer to?",
                "Will we meet in heaven?",
                "Who stole my light?",
                "Where could the other sock be that I couldn't find the other day?",
                "How many times have I risen from my ashes like a phoenix?",
                "What will fill this void?",
                "Is what I see real or is it a dream?",
                "In my fight with the past, will I ever be proven right?",
                "Why am I crying? Why can't I cry?",
                "Is ownership a digital echo of existence?",
                "Which NFT I own is the artist's attempt at immortality?",
                "Which pieces in my collection do I keep not in my home or my wallet, but in my heart?",
                "Does infinite access diminish meaning?",
                "While searching for a 'Grail' piece, what absence am I truly seeking?",
                "Does poetry name colors, or do colors give birth to poetry?",
                "With which color would I paint my favorite poem?",
                "Does the value of art arise from its aesthetics or from its confession?",
                "Which brushstroke replaces a real dream?",
                "Is the vibration of colors a universal language or a personal scream?",
                "Can an artwork of art ever truly be considered 'complete'?",
                "Is art a form of rebellion, or a space of reconciliation?",
                "Who is ready to dance with my soul?",
                "Is the night dark, or am I the one left in darkness?",
                "Am I still innocent?",
                "Why does a poisonous familiarity feel safer than a healthy unknown?",
                "Will this pain ever serve a purpose one day?",
                "Do they love me for my own light, or because I can hold their shadows within me?",
                "Will I win?",
                "WHY?",
                "HOW?",
                "WHEN?",
                "What is the matrix ulan?"
            ];
            
            let mirrorIndex = 0; // Her ayna i√ßin index
            
            const mirrorData = [
                {"id":1,"type":"round","position":{"x":-101.024,"y":1.4,"z":13.306},"rotation":{"x":0,"y":256.155,"z":0},"scale":{"x":0.6,"y":0.6,"z":0.6}},
                {"id":3,"type":"round","position":{"x":-104.281,"y":-1.2,"z":-1.051},"rotation":{"x":0,"y":260.52,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":5,"type":"round","position":{"x":-102.098,"y":2.458,"z":-14.478},"rotation":{"x":0,"y":258.208,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":6,"type":"round","position":{"x":-100.417,"y":2.414,"z":-21.125},"rotation":{"x":0,"y":259.957,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":7,"type":"round","position":{"x":-97.435,"y":2.393,"z":-26.899},"rotation":{"x":0,"y":261.528,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":10,"type":"round","position":{"x":-83.427,"y":2.401,"z":-40.608},"rotation":{"x":0,"y":259.005,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":11,"type":"round","position":{"x":-76.818,"y":2.412,"z":-43.512},"rotation":{"x":0,"y":260.051,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":12,"type":"round","position":{"x":-70.209,"y":2.423,"z":-46.416},"rotation":{"x":0,"y":261.071,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":13,"type":"round","position":{"x":-63.388,"y":-0.5,"z":-47.651},"rotation":{"x":0,"y":262.12,"z":0},"scale":{"x":0.9,"y":0.9,"z":0.9}},
                {"id":17,"type":"round","position":{"x":-43.347,"y":-5.6,"z":-50.676},"rotation":{"x":0,"y":261.201,"z":0},"scale":{"x":0.7,"y":0.7,"z":0.7}},
                {"id":19,"type":"round","position":{"x":-22.811,"y":2.479,"z":-32.932},"rotation":{"x":0,"y":258.601,"z":0},"scale":{"x":0.8,"y":0.8,"z":0.8}},
                {"id":21,"type":"round","position":{"x":-14.133,"y":2.493,"z":-20.1},"rotation":{"x":0,"y":256.54,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":27,"type":"round","position":{"x":13.806,"y":2.484,"z":21.597},"rotation":{"x":0,"y":256.238,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":33,"type":"round","position":{"x":50.092,"y":-7,"z":41.74},"rotation":{"x":0,"y":257.317,"z":0},"scale":{"x":0.9,"y":0.9,"z":0.9}},
                {"id":36,"type":"round","position":{"x":72.844,"y":2.482,"z":44.532},"rotation":{"x":0,"y":260.76,"z":0},"scale":{"x":0.8,"y":0.8,"z":0.8}},
                {"id":41,"type":"round","position":{"x":99.776,"y":-1.5,"z":20.448},"rotation":{"x":0,"y":256.97,"z":0},"scale":{"x":0.8,"y":0.8,"z":0.8}},
                {"id":42,"type":"round","position":{"x":91.183,"y":2.429,"z":34.476},"rotation":{"x":0,"y":259.135,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":44,"type":"round","position":{"x":103.528,"y":2.522,"z":-1.804},"rotation":{"x":0,"y":257.269,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":47,"type":"round","position":{"x":96.404,"y":2.486,"z":-22.662},"rotation":{"x":0,"y":257.072,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":49,"type":"round","position":{"x":88.461,"y":2.647,"z":-35.953},"rotation":{"x":0,"y":260.352,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":52,"type":"round","position":{"x":66.326,"y":4.588,"z":-46.38},"rotation":{"x":0,"y":257.785,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":53,"type":"round","position":{"x":60.13,"y":5.604,"z":-47.34},"rotation":{"x":0,"y":258.825,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":56,"type":"round","position":{"x":43.982,"y":8.632,"z":-46.934},"rotation":{"x":0,"y":262.04,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":58,"type":"round","position":{"x":34.561,"y":0.4,"z":-43.397},"rotation":{"x":0,"y":258.448,"z":0},"scale":{"x":0.9,"y":0.9,"z":0.9}},
                {"id":60,"type":"round","position":{"x":24.07,"y":13.306,"z":-38.074},"rotation":{"x":0,"y":261.827,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":64,"type":"round","position":{"x":12.293,"y":16.183,"z":-19.495},"rotation":{"x":0,"y":257.659,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":65,"type":"round","position":{"x":6.747,"y":16.486,"z":-12.499},"rotation":{"x":0,"y":259.863,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":68,"type":"round","position":{"x":-5.452,"y":17.052,"z":7.066},"rotation":{"x":0,"y":259.645,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":72,"type":"round","position":{"x":-22.309,"y":16.344,"z":18.882},"rotation":{"x":0,"y":259.211,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":74,"type":"round","position":{"x":-31.264,"y":14.104,"z":34.524},"rotation":{"x":0,"y":261.354,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":75,"type":"round","position":{"x":-46.756,"y":12.72,"z":39.633},"rotation":{"x":0,"y":262.375,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":2,"type":"rectangular","position":{"x":-93.201,"y":3.888,"z":28.491},"rotation":{"x":0,"y":258.364,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":4,"type":"rectangular","position":{"x":-103.132,"y":4.8,"z":16.345},"rotation":{"x":0,"y":256.292,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":8,"type":"rectangular","position":{"x":-103.004,"y":3.794,"z":-9.36},"rotation":{"x":0,"y":256.641,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":9,"type":"rectangular","position":{"x":-67.338,"y":5.1,"z":-44.288},"rotation":{"x":0,"y":257.884,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":14,"type":"rectangular","position":{"x":-96.942,"y":3.854,"z":-25.652},"rotation":{"x":0,"y":256.964,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":15,"type":"rectangular","position":{"x":-84.229,"y":3.871,"z":-39.37},"rotation":{"x":0,"y":258.214,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":18,"type":"rectangular","position":{"x":-16.976,"y":3.877,"z":-25.2},"rotation":{"x":0,"y":256.677,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":20,"type":"rectangular","position":{"x":-26.885,"y":3.886,"z":-38.323},"rotation":{"x":0,"y":260.663,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":22,"type":"rectangular","position":{"x":-78.201,"y":3.897,"z":41.189},"rotation":{"x":0,"y":258.751,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":26,"type":"rectangular","position":{"x":-8.015,"y":3.892,"z":-9.903},"rotation":{"x":0,"y":260.782,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":29,"type":"rectangular","position":{"x":9.639,"y":3.882,"z":15.962},"rotation":{"x":0,"y":259.186,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":31,"type":"rectangular","position":{"x":24.524,"y":3.889,"z":30.943},"rotation":{"x":0,"y":261.537,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":32,"type":"rectangular","position":{"x":33.228,"y":3.898,"z":40.835},"rotation":{"x":0,"y":256.296,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":34,"type":"rectangular","position":{"x":64.947,"y":3.906,"z":44.357},"rotation":{"x":0,"y":258.368,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":39,"type":"rectangular","position":{"x":91.357,"y":3.826,"z":28.054},"rotation":{"x":0,"y":259.252,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":43,"type":"rectangular","position":{"x":102.604,"y":3.862,"z":6.87},"rotation":{"x":0,"y":261.346,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":46,"type":"rectangular","position":{"x":105.297,"y":3.97,"z":-12.648},"rotation":{"x":0,"y":261.458,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":50,"type":"rectangular","position":{"x":94.68,"y":4.62,"z":-25.649},"rotation":{"x":0,"y":261.73,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":51,"type":"rectangular","position":{"x":75.771,"y":8.9,"z":-38.948},"rotation":{"x":0,"y":256.674,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":54,"type":"rectangular","position":{"x":56.013,"y":10.3,"z":-44.515},"rotation":{"x":0,"y":259.846,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":61,"type":"rectangular","position":{"x":38.377,"y":15.3,"z":-41.137},"rotation":{"x":0,"y":257.485,"z":0},"scale":{"x":0.8,"y":0.8,"z":0.8}},
                {"id":62,"type":"rectangular","position":{"x":20.448,"y":16.386,"z":-28.648},"rotation":{"x":0,"y":259.561,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":66,"type":"rectangular","position":{"x":11.244,"y":18.189,"z":-16.164},"rotation":{"x":0,"y":262.005,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":69,"type":"rectangular","position":{"x":-1.287,"y":18.527,"z":3.459},"rotation":{"x":0,"y":261.364,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":73,"type":"rectangular","position":{"x":-18.397,"y":16.888,"z":24.645},"rotation":{"x":0,"y":260.316,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":76,"type":"rectangular","position":{"x":-37.984,"y":12.464,"z":40.528},"rotation":{"x":0,"y":257.15,"z":0},"scale":{"x":1,"y":1,"z":1}},
                {"id":77,"type":"rectangular","position":{"x":-54.952,"y":10.536,"z":44.362},"rotation":{"x":0,"y":258.295,"z":0},"scale":{"x":1,"y":1,"z":1}}
            ];

            mirrorData.forEach((data) => {
                const isRoundMirror = data.type === 'round';
                const mirrorURL = isRoundMirror 
                    ? 'https://busrasuhaydar.github.io/yuvarlak-ayna/ayna1.glb'
                    : 'https://busrasuhaydar.github.io/ayna/ayna.glb';

                // Her ayna i√ßin farklƒ± sorular - √ñN ve ARKA!
                const currentQuestionFront = mirrorQuestions[mirrorIndex % mirrorQuestions.length];
                const currentQuestionBack = mirrorQuestionsBack[mirrorIndex % mirrorQuestionsBack.length];
                const textTextureFront = createTextTexture(currentQuestionFront);
                const textTextureBack = createTextTextureBack(currentQuestionBack); // ARKA Y√úZ ƒ∞√áƒ∞N √ñZEL FONKSƒ∞YON!
                const currentMirrorIndex = mirrorIndex; // Bu ayna i√ßin index'i kaydet
                mirrorIndex++;

                mirrorsCreated++;

                mirrorLoader.load(mirrorURL,
                    function(gltf) {
                        mirrorsLoaded++;
                        const mirror = gltf.scene;
                        
                        mirror.position.set(data.position.x, data.position.y, data.position.z);
                        
                        const degToRad = Math.PI / 180;
                        mirror.rotation.set(
                            data.rotation.x * degToRad,
                            data.rotation.y * degToRad,
                            data.rotation.z * degToRad
                        );
                        
                        mirror.scale.set(data.scale.x, data.scale.y, data.scale.z);
                        
                        let mirrorMesh = null;
                        let maxArea = 0;
                        
                        mirror.traverse(function(child) {
                            if (child.isMesh) {
                                const bbox = new THREE.Box3().setFromObject(child);
                                const size = bbox.getSize(new THREE.Vector3());
                                const area = size.x * size.y;
                                
                                if (area > maxArea) {
                                    maxArea = area;
                                    mirrorMesh = child;
                                }
                                
                                const mirrorMaterial = new THREE.MeshBasicMaterial({
                                    envMap: cubeRenderTarget.texture,
                                    reflectivity: 1.0,
                                    refractionRatio: 0.98,
                                    combine: THREE.MixOperation,
                                    side: THREE.DoubleSide
                                });
                                
                                child.material = mirrorMaterial;
                                child.castShadow = false;
                                child.receiveShadow = false;
                                
                                mirrorMeshes.push(child);
                            }
                        });
                        
                        scene.add(mirror);
                        
                        if (mirrorMesh) {
                            mirrorMesh.geometry.computeBoundingBox();
                            const bbox = mirrorMesh.geometry.boundingBox;
                            const size = new THREE.Vector3();
                            bbox.getSize(size);
                            
                            const axes = [
                                { name: 'x', value: size.x },
                                { name: 'y', value: size.y },
                                { name: 'z', value: size.z }
                            ];
                            axes.sort((a, b) => a.value - b.value);
                            const thinnestAxis = axes[0].name;
                            
                            const stickerWidth = axes[2].value * 0.5;
                            const stickerHeight = axes[1].value * 0.3;
                            
                            const stickerMaterialFront = new THREE.MeshBasicMaterial({
                                map: textTextureFront,
                                transparent: true,
                                side: THREE.DoubleSide, // FrontSide yerine DoubleSide!
                                depthWrite: false,
                                depthTest: true,
                                alphaTest: 0.1,
                                opacity: 1.0
                            });
                            const stickerGeometryFront = new THREE.PlaneGeometry(stickerWidth, stickerHeight);
                            const stickerFront = new THREE.Mesh(stickerGeometryFront, stickerMaterialFront);
                            
                            const stickerMaterialBack = new THREE.MeshBasicMaterial({
                                map: textTextureBack,
                                transparent: true,
                                side: THREE.DoubleSide, // FrontSide yerine DoubleSide!
                                depthWrite: false,
                                depthTest: true,
                                alphaTest: 0.1,
                                opacity: 1.0
                            });
                            const stickerGeometryBack = new THREE.PlaneGeometry(stickerWidth, stickerHeight);
                            const stickerBack = new THREE.Mesh(stickerGeometryBack, stickerMaterialBack);
                            
                            if (thinnestAxis === 'x') {
                                stickerFront.position.x = size.x / 2 + 0.05; // Daha uzak
                                stickerFront.rotation.y = Math.PI / 2;
                                if (isRoundMirror) {
                                    stickerFront.scale.x = -1; // Geri ekle
                                    stickerFront.rotation.z = -Math.PI * (66.5/180);
                                }
                                stickerBack.position.x = -size.x / 2 - 0.05; // Daha uzak
                                stickerBack.rotation.y = -Math.PI / 2;
                                if (isRoundMirror) {
                                    stickerBack.scale.x = -1; // Geri ekle
                                    stickerBack.rotation.z = Math.PI + Math.PI * (66.5/180); // 180¬∞ + 66.5¬∞ = d√ºz!
                                }
                            } else if (thinnestAxis === 'y') {
                                stickerFront.position.y = size.y / 2 + 0.05; // Daha uzak
                                stickerFront.rotation.x = -Math.PI / 2;
                                if (isRoundMirror) {
                                    stickerFront.scale.x = -1; // Geri ekle
                                    stickerFront.rotation.z = -Math.PI * (66.5/180);
                                }
                                stickerBack.position.y = -size.y / 2 - 0.05; // Daha uzak
                                stickerBack.rotation.x = Math.PI / 2;
                                if (isRoundMirror) {
                                    stickerBack.scale.x = -1; // Geri ekle
                                    stickerBack.rotation.z = Math.PI + Math.PI * (66.5/180); // 180¬∞ + 66.5¬∞ = d√ºz!
                                }
                            } else {
                                stickerFront.position.z = size.z / 2 + 0.05; // Daha uzak
                                if (isRoundMirror) {
                                    stickerFront.scale.x = -1; // Geri ekle
                                    stickerFront.rotation.z = -Math.PI * (66.5/180);
                                }
                                stickerBack.position.z = -size.z / 2 - 0.05; // Daha uzak
                                stickerBack.rotation.y = Math.PI;
                                if (isRoundMirror) {
                                    stickerBack.scale.x = -1; // Geri ekle
                                    stickerBack.rotation.z = Math.PI + Math.PI * (66.5/180); // 180¬∞ + 66.5¬∞ = d√ºz!
                                }
                            }
                            
                            mirrorMesh.add(stickerFront);
                            mirrorMesh.add(stickerBack);
                        }
                        
                        if (gltf.animations && gltf.animations.length > 0) {
                            const mixer = new THREE.AnimationMixer(mirror);
                            gltf.animations.forEach(clip => mixer.clipAction(clip).play());
                            mirrorMixers.push(mixer);
                        }
                        
                        // HER AYNA FARKLI Y√ñNE D√ñNS√úN - Sƒ±rayla saƒüa/sola!
                        const baseSpeed = isRoundMirror ? 0.01092 : 0.0104;
                        const rotationSpeed = currentMirrorIndex % 2 === 0 ? baseSpeed : -baseSpeed;
                        rotatingMirrors.push({ mesh: mirror, rotationSpeed: rotationSpeed });
                        
                        if (mirrorsLoaded % 15 === 0 || mirrorsLoaded === TOTAL_MIRRORS) {
                        }
                    },
                    undefined,
                    function(error) {
                    }
                );
            });
            
        }

        function findNearestPointOnPath(position) {
            if (!pathCurve) return { t: 0, point: position, distance: 0 };
            
            let minDist = Infinity;
            let bestT = 0;
            let bestPoint = null;
            
            // √áOK DAHA FAZLA SAMPLE! (200 ‚Üí 500)
            const samples = 500;
            for (let i = 0; i < samples; i++) {
                const t = i / samples;
                const point = pathCurve.getPoint(t);
                
                // üö® FARKLI KAT KONTROL√ú!
                const heightDiff = Math.abs(point.y - position.y);
                
                // Y√ºkseklik farkƒ± 3 birimden fazlaysa IGNORE ET! (Farklƒ± kat!)
                if (heightDiff > 3.0) continue;
                
                const dist = position.distanceTo(point);
                
                if (dist < minDist) {
                    minDist = dist;
                    bestT = t;
                    bestPoint = point;
                }
            }
            
            // ƒ∞Kƒ∞NCƒ∞ A≈ûAMA: En yakƒ±n noktanƒ±n etrafƒ±nda DAHA HASSAS arama!
            if (bestPoint) {
                const refineSamples = 50;
                const refineRange = 2.0 / samples;
                
                for (let i = 0; i < refineSamples; i++) {
                    const offset = (i / refineSamples - 0.5) * refineRange;
                    const t = Math.max(0, Math.min(1, bestT + offset));
                    const point = pathCurve.getPoint(t);
                    
                    // üö® Yine farklƒ± kat kontrol√º!
                    const heightDiff = Math.abs(point.y - position.y);
                    if (heightDiff > 3.0) continue;
                    
                    const dist = position.distanceTo(point);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        bestT = t;
                        bestPoint = point;
                    }
                }
            }
            
            return { t: bestT, point: bestPoint, distance: minDist };
        }

        function resetCameraForMode(mode) {
            if (mode === 0) {
                cameraYaw = DEFAULT_CAMERA_SETTINGS.mode0.yaw;
                cameraPitch = DEFAULT_CAMERA_SETTINGS.mode0.pitch;
                cameraDistance = DEFAULT_CAMERA_SETTINGS.mode0.distance;
                camera.fov = DEFAULT_CAMERA_SETTINGS.mode0.fov;
            } else if (mode === 1) {
                cameraPitch = DEFAULT_CAMERA_SETTINGS.mode1.pitch;
                cameraYaw = DEFAULT_CAMERA_SETTINGS.mode1.yaw;
                cameraDistance = DEFAULT_CAMERA_SETTINGS.mode1.distance;
                camera.fov = DEFAULT_CAMERA_SETTINGS.mode1.fov;
            } else if (mode === 2) {
                cameraTheta = DEFAULT_CAMERA_SETTINGS.mode2.theta;
                cameraPhi = DEFAULT_CAMERA_SETTINGS.mode2.phi;
                cameraRadius = DEFAULT_CAMERA_SETTINGS.mode2.radius;
                camera.fov = DEFAULT_CAMERA_SETTINGS.mode2.fov;
            }
            
            camera.updateProjectionMatrix();
            currentLookAt.set(0, 0, 0);
        }

        // üì± MOBƒ∞L KONTROL DEƒûƒ∞≈ûKENLERƒ∞
        const mobileControls = {
            left: false,
            right: false,
            forward: false,
            backward: false
        };

        function setupControls() {
            // ü•Ω VR OTOMATƒ∞K ALGILAMA - Sadece VR varsa g√∂ster!
            const vrBtn = document.getElementById('vrBtn');
            if (vrBtn && navigator.xr) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrBtn.style.display = 'flex';  // VR varsa g√∂ster!
                    }
                });
                
                vrBtn.addEventListener('click', () => {
                    if (navigator.xr) {
                        navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                            if (supported) {
                                if (!renderer.xr.isPresenting) {
                                    navigator.xr.requestSession('immersive-vr').then((session) => {
                                        renderer.xr.setSession(session);
                                        vrBtn.classList.add('vr-active');
                                    });
                                } else {
                                    renderer.xr.getSession().end();
                                    vrBtn.classList.remove('vr-active');
                                }
                            }
                        });
                    }
                });
            }
            
            // üéÆ GAMEPAD DESTEƒûƒ∞ - Otomatik algƒ±lama!
            let gamepadIndex = -1;
            let gamepadConnected = false;
            
            window.addEventListener('gamepadconnected', (e) => {
                gamepadIndex = e.gamepad.index;
                gamepadConnected = true;
                console.log('üéÆ Gamepad connected:', e.gamepad.id);
            });
            
            window.addEventListener('gamepaddisconnected', (e) => {
                if (e.gamepad.index === gamepadIndex) {
                    gamepadConnected = false;
                    gamepadIndex = -1;
                }
            });
            
            // üéÆ Gamepad okuma fonksiyonu
            function updateGamepad() {
                if (!gamepadConnected) return;
                
                const gamepads = navigator.getGamepads();
                if (!gamepads || gamepadIndex < 0) return;
                
                const gamepad = gamepads[gamepadIndex];
                if (!gamepad) return;
                
                // Left stick - Direksiyon (X axis)
                const stickX = gamepad.axes[0];  // Sol/Saƒü
                if (Math.abs(stickX) > 0.15) {  // Dead zone
                    mobileControls.left = stickX < -0.15;
                    mobileControls.right = stickX > 0.15;
                } else {
                    mobileControls.left = false;
                    mobileControls.right = false;
                }
                
                // Right trigger (RT) - ƒ∞leri (axis 7 veya button 7)
                const rightTrigger = gamepad.buttons[7] ? gamepad.buttons[7].value : 0;
                mobileControls.forward = rightTrigger > 0.1;
                
                // Left trigger (LT) - Geri (axis 6 veya button 6)
                const leftTrigger = gamepad.buttons[6] ? gamepad.buttons[6].value : 0;
                mobileControls.backward = leftTrigger > 0.1;
                
                // A button (button 0) - ƒ∞leri alternatif
                if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
                    mobileControls.forward = true;
                }
                
                // B button (button 1) - Geri alternatif
                if (gamepad.buttons[1] && gamepad.buttons[1].pressed) {
                    mobileControls.backward = true;
                }
                
                // Y button (button 3) - Kamera deƒüi≈ütir
                if (gamepad.buttons[3] && gamepad.buttons[3].pressed && !gamepad.buttons[3].wasPressed) {
                    cameraMode = (cameraMode + 1) % 3;
                    resetCameraForMode(cameraMode);
                    const cameraBtn = document.getElementById('cameraBtn');
                    if (cameraBtn) cameraBtn.textContent = ['üì∑', 'üëÅÔ∏è', 'üé•'][cameraMode];
                }
                gamepad.buttons[3].wasPressed = gamepad.buttons[3].pressed;
            }
            
            // Gamepad'i her frame g√ºncelle
            const originalUpdateCar = updateCar;
            updateCar = function() {
                updateGamepad();
                originalUpdateCar();
            };
            
            // üì∑ CAMERA MODE BUTTON
            const cameraBtn = document.getElementById('cameraBtn');
            const cameraIcons = ['üì∑', 'üëÅÔ∏è', 'üé•'];
            
            if (cameraBtn) {
                const cameraBtnHandler = (e) => {
                    e.preventDefault();
                    cameraMode = (cameraMode + 1) % 3;
                    cameraBtn.textContent = cameraIcons[cameraMode];
                    resetCameraForMode(cameraMode);
                };
                
                cameraBtn.addEventListener('touchstart', cameraBtnHandler);
                cameraBtn.addEventListener('click', cameraBtnHandler);
            }
            
            // üéÆ STEERING CONTROLS
            const leftArrow = document.getElementById('leftArrow');
            const rightArrow = document.getElementById('rightArrow');
            
            if (leftArrow) {
                leftArrow.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mobileControls.left = true;
                });
                leftArrow.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mobileControls.left = false;
                });
            }
            
            if (rightArrow) {
                rightArrow.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mobileControls.right = true;
                });
                rightArrow.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mobileControls.right = false;
                });
            }
            
            // üöÄ ACCELERATION CONTROLS
            const upArrow = document.getElementById('upArrow');
            const downArrow = document.getElementById('downArrow');
            
            if (upArrow) {
                upArrow.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mobileControls.forward = true;
                });
                upArrow.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mobileControls.forward = false;
                });
            }
            
            if (downArrow) {
                downArrow.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mobileControls.backward = true;
                });
                downArrow.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mobileControls.backward = false;
                });
            }
            
            // DESKTOP KEYBOARD
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                if (event.code === 'KeyC') {
                    cameraMode = (cameraMode + 1) % 3;
                    resetCameraForMode(cameraMode);
                }
            });
            
            document.addEventListener('keyup', (event) => { 
                keys[event.code] = false; 
            });

            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('mousedown', (event) => {
                    isMouseDown = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                });

                document.addEventListener('mousemove', (event) => {
                    if (isMouseDown) {
                        const deltaX = event.clientX - mouseX;
                        const deltaY = event.clientY - mouseY;
                        
                        if (cameraMode === 0) {
                            cameraYaw -= deltaX * 0.005;
                            cameraPitch = Math.max(-Math.PI/2.3, Math.min(Math.PI/3, cameraPitch + deltaY * 0.005));
                        } else if (cameraMode === 1) {
                            cameraYaw -= deltaX * 0.005;
                            cameraPitch = Math.max(-Math.PI/3, Math.min(Math.PI/6, cameraPitch + deltaY * 0.005));
                        } else if (cameraMode === 2) {
                            cameraTheta -= deltaX * 0.01;
                            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + deltaY * 0.01));
                        }
                        
                        mouseX = event.clientX;
                        mouseY = event.clientY;
                    }
                });

                document.addEventListener('mouseup', () => { 
                    isMouseDown = false; 
                });

                renderer.domElement.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const zoomFactor = event.deltaY > 0 ? 1.05 : 0.95;
                    camera.fov = Math.max(20, Math.min(120, camera.fov * zoomFactor));
                    camera.updateProjectionMatrix();
                    
                    if (cameraMode === 0) {
                        cameraDistance = Math.max(5, Math.min(50, cameraDistance + event.deltaY * 0.05));
                    } else if (cameraMode === 1) {
                        cameraDistance = Math.max(0, Math.min(10, cameraDistance + event.deltaY * 0.02));
                    } else if (cameraMode === 2) {
                        cameraRadius = Math.max(10, Math.min(500, cameraRadius + event.deltaY * 0.5));
                    }
                }, { passive: false });
            }
        }

        function updateCar() {
            if (!car) return;
            
            // Desktop + Mobile kontrol birle≈üimi
            const isForward = keys['ArrowUp'] || keys['KeyW'] || mobileControls.forward;
            const isBackward = keys['ArrowDown'] || keys['KeyS'] || mobileControls.backward;
            const isLeft = keys['ArrowLeft'] || keys['KeyA'] || mobileControls.left;
            const isRight = keys['ArrowRight'] || keys['KeyD'] || mobileControls.right;
            
            if (isForward) {
                carSpeed = Math.min(carSpeed + acceleration, maxSpeed);
            } else if (isBackward) {
                carSpeed = Math.max(carSpeed - acceleration, -maxSpeed * 0.5);
            } else {
                if (carSpeed > 0) carSpeed = Math.max(0, carSpeed - deceleration);
                else if (carSpeed < 0) carSpeed = Math.min(0, carSpeed + deceleration);
            }

            if (isLeft) {
                turnSpeed = Math.max(turnSpeed - 0.0015, -maxTurnSpeed);
            } else if (isRight) {
                turnSpeed = Math.min(turnSpeed + 0.0015, maxTurnSpeed);
            } else {
                turnSpeed *= 0.88;
            }

            if (Math.abs(carSpeed) > 0.001) {
                car.rotation.y += turnSpeed * (carSpeed / maxSpeed) * 1.5;
                const moveX = Math.sin(car.rotation.y) * carSpeed;
                const moveZ = Math.cos(car.rotation.y) * carSpeed;
                car.position.x -= moveX;
                car.position.z -= moveZ;
                smoothCarPosition.x = car.position.x;
                smoothCarPosition.z = car.position.z;
            }
            
            const nearest = findNearestPointOnPath(car.position);
            
            if (nearest && nearest.point) {
                const maxDistance = 5.5;
                const currentDistance = nearest.distance;
                
                if (currentDistance > maxDistance) {
                    const overDistance = currentDistance - maxDistance;
                    const distanceChange = currentDistance - lastRoadDistance;
                    const smoothOverDistance = Math.abs(distanceChange) < 0.2 ? overDistance : overDistance * 0.7;
                    
                    const pullX = (nearest.point.x - car.position.x) / currentDistance;
                    const pullZ = (nearest.point.z - car.position.z) / currentDistance;
                    
                    roadPullAccumulator.x += pullX * smoothOverDistance * 0.08;
                    roadPullAccumulator.y += pullZ * smoothOverDistance * 0.08;
                    roadPullAccumulator.x *= 0.85;
                    roadPullAccumulator.y *= 0.85;
                    
                    car.position.x += roadPullAccumulator.x;
                    car.position.z += roadPullAccumulator.y;
                    smoothCarPosition.x = car.position.x;
                    smoothCarPosition.z = car.position.z;
                } else {
                    roadPullAccumulator.x *= 0.9;
                    roadPullAccumulator.y *= 0.9;
                }
                
                lastRoadDistance = currentDistance;
                
                // üéØ SAND.HTML Sƒ∞STEMƒ∞ - BASƒ∞T VE ETKƒ∞Lƒ∞!
                const currentRoadHeight = nearest.point.y;
                
                // Tek lookahead - √ñN√úNE BAK!
                const lookaheadDistance = 4.2;
                const lookaheadPos = new THREE.Vector3(
                    car.position.x - Math.sin(car.rotation.y) * lookaheadDistance,
                    car.position.y,
                    car.position.z - Math.cos(car.rotation.y) * lookaheadDistance
                );
                
                const lookaheadNearest = findNearestPointOnPath(lookaheadPos);
                const lookaheadHeight = lookaheadNearest && lookaheadNearest.point ? 
                    lookaheadNearest.point.y : currentRoadHeight;
                
                const heightChange = lookaheadHeight - currentRoadHeight;
                const isClimbingUp = heightChange > 0.15;
                const isGoingDown = heightChange < -0.15;
                
                let targetHeight;
                let offset;
                
                if (isClimbingUp) {
                    const blend = 0.65;
                    targetHeight = lookaheadHeight * blend + currentRoadHeight * (1 - blend);
                    offset = 0.68;
                } else if (isGoingDown) {
                    const blend = 0.55;
                    targetHeight = lookaheadHeight * blend + currentRoadHeight * (1 - blend);
                    offset = 0.48;
                } else {
                    targetHeight = currentRoadHeight;
                    offset = 0.27;
                }
                
                const desiredHeight = targetHeight + offset;
                
                const heightDiff = desiredHeight - car.position.y;
                const absDiff = Math.abs(heightDiff);
                
                let smoothFactor;
                if (isClimbingUp && absDiff > 0.2) {
                    smoothFactor = 0.12;  // 0.18 ‚Üí 0.12 √ßok daha smooth!
                } else if (isGoingDown && absDiff > 0.2) {
                    smoothFactor = 0.10;  // 0.16 ‚Üí 0.10 √ßok daha smooth!
                } else if (absDiff > 2.0) {
                    smoothFactor = 0.06;  // 0.10 ‚Üí 0.06
                } else if (absDiff > 1.0) {
                    smoothFactor = 0.05;  // 0.08 ‚Üí 0.05
                } else if (absDiff > 0.4) {
                    smoothFactor = 0.04;  // 0.06 ‚Üí 0.04
                } else {
                    smoothFactor = 0.03;  // 0.04 ‚Üí 0.03
                }
                
                car.position.y += heightDiff * smoothFactor;
                smoothCarPosition.y = car.position.y;
                smoothCarHeight = car.position.y;
            }
        }

        function updateCamera() {
            if (!car || !camera) return;
            const lerpFactor = 0.04;
            
            if (cameraMode === 0) {
                // üåßÔ∏è Copilot dƒ±≈üƒ±nda yaƒümuru kapat (TELEFON HARƒ∞√á!)
                if (!isPhone && rainActive) {
                    rainActive = false;
                    rainLayers.forEach(layer => layer.mesh.visible = false);
                    console.log('‚òÄÔ∏è Yaƒümur durdu!');
                }
                
                const followDistance = cameraDistance;
                const cameraHeight = 8;
                const carDirection = new THREE.Vector3(0, 0, 1);
                carDirection.applyQuaternion(car.quaternion);
                carDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
                const cameraOffset = carDirection.multiplyScalar(followDistance);
                cameraOffset.y = cameraHeight + cameraPitch * 10;
                targetCameraPosition.copy(car.position).add(cameraOffset);
                targetCameraPosition.y = Math.max(2, targetCameraPosition.y);
                
                camera.position.lerp(targetCameraPosition, lerpFactor);
                
                const lookAhead = new THREE.Vector3(0, 0, -1);
                lookAhead.applyQuaternion(car.quaternion);
                targetLookAt.copy(car.position).add(lookAhead.multiplyScalar(10));
                targetLookAt.y = Math.max(1, car.position.y + 2);
                
                if (!currentLookAt.x && !currentLookAt.y && !currentLookAt.z) {
                    currentLookAt.copy(targetLookAt);
                }
                currentLookAt.lerp(targetLookAt, lerpFactor);
                camera.lookAt(currentLookAt);
                
            } else if (cameraMode === 1) {
                // üåßÔ∏è Copilot modunda T√úM KATMANLARI aktif et! (TELEFON ZATEN AKTƒ∞F!)
                if (!isPhone && !rainActive) {
                    rainActive = true;
                    rainLayers.forEach(layer => layer.mesh.visible = true);
                    console.log('üåßÔ∏è Katmanlƒ± yaƒümur ba≈üladƒ±!');
                }
                
                const cockpitOffset = new THREE.Vector3(0, 1.8, -2.8);
                cockpitOffset.applyQuaternion(car.quaternion);
                targetCameraPosition.copy(car.position).add(cockpitOffset);
                targetCameraPosition.y = Math.max(2, targetCameraPosition.y);
                camera.position.lerp(targetCameraPosition, lerpFactor * 6);
                
                const lookDirection = new THREE.Vector3(
                    Math.sin(cameraYaw),
                    cameraPitch,
                    -Math.cos(cameraYaw)
                );
                lookDirection.normalize();
                lookDirection.applyQuaternion(car.quaternion);
                targetLookAt.copy(camera.position).add(lookDirection.multiplyScalar(100));
                targetLookAt.y = Math.max(0.5, targetLookAt.y);
                
                if (!currentLookAt.x && !currentLookAt.y && !currentLookAt.z) {
                    currentLookAt.copy(targetLookAt);
                }
                currentLookAt.lerp(targetLookAt, lerpFactor * 6);
                camera.lookAt(currentLookAt);
                
            } else if (cameraMode === 2) {
                // üåßÔ∏è Copilot dƒ±≈üƒ±nda yaƒümuru kapat (TELEFON HARƒ∞√á!)
                if (!isPhone && rainActive) {
                    rainActive = false;
                    rainLayers.forEach(layer => layer.mesh.visible = false);
                }
                
                const x = car.position.x + cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
                const y = car.position.y + cameraRadius * Math.cos(cameraPhi);
                const z = car.position.z + cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
                targetCameraPosition.set(x, Math.max(2, y), z);
                camera.position.lerp(targetCameraPosition, lerpFactor);
                
                targetLookAt.copy(car.position);
                if (!currentLookAt.x && !currentLookAt.y && !currentLookAt.z) {
                    currentLookAt.copy(targetLookAt);
                }
                currentLookAt.lerp(targetLookAt, lerpFactor);
                camera.lookAt(currentLookAt);
            }
        }

        // üîÑ THROTTLED RESIZE - Her resize'da render etme!
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // üì± Mobilde resize sonrasƒ± hafƒ±za temizliƒüi!
                if (isMobile && renderer.info) {
                    renderer.info.reset();
                }
            }, 250); // 250ms throttle
        });
        
        // üì± YATAY MOD - BASƒ∞T VE G√úVENLƒ∞ √á√ñZ√úM!
        let isHandlingOrientation = false;
        
        const safeOrientationHandler = () => {
            if (isHandlingOrientation) return;  // Zaten i≈üleniyor!
            isHandlingOrientation = true;
            
            console.log('üîÑ Orientation changing...');
            
            // Basit ve g√ºvenli yeniden boyutlandƒ±rma
            setTimeout(() => {
                try {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    console.log('‚úÖ Orientation handled successfully!');
                } catch (error) {
                    console.error('‚ùå Orientation error:', error);
                }
                
                isHandlingOrientation = false;
            }, 200);
        };
        
        // Hem orientationchange hem resize'ƒ± dinle
        window.addEventListener('orientationchange', safeOrientationHandler);
        window.addEventListener('resize', () => {
            if (Math.abs(window.orientation || 0) % 90 === 0) {
                // Bu bir orientation change
                safeOrientationHandler();
            }
        });
        
        // üì± SAYFA KAPANIRKEN TEMƒ∞ZLƒ∞K
        window.addEventListener('beforeunload', () => {
            // Texture'larƒ± temizle
            universeTextures.forEach(tex => tex && tex.dispose());
            pourTextures.forEach(tex => tex && tex.dispose());
            
            // Geometry'leri temizle
            scene.traverse((obj) => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            
            // Renderer'ƒ± temizle
            renderer.dispose();
        });

        // üì± HAFIZA ƒ∞ZLEME VE TEMƒ∞ZLƒ∞K Sƒ∞STEMƒ∞
        let lastMemoryCheck = Date.now();
        function checkMemory() {
            // Mobilde her 3 saniye, desktop'ta 5 saniye
            const checkInterval = isMobile ? 3000 : 5000;
            if (Date.now() - lastMemoryCheck > checkInterval) {
                lastMemoryCheck = Date.now();
                
                // Renderer'ƒ± temizle
                if (renderer.info) {
                    renderer.info.reset();
                }
                
                // üì± MOBƒ∞L: AGRESIF TEXTURE TEMƒ∞ZLƒ∞ƒûƒ∞!
                if (isMobile) {
                    // Limit a≈üƒ±ldƒ±ysa temizle
                    if (activeTextureIndices.size > MAX_LOADED_TEXTURES) {
                        const toRemove = Math.ceil((activeTextureIndices.size - MAX_LOADED_TEXTURES) * 1.5);  // %50 fazla temizle!
                        let removed = 0;
                        
                        activeTextureIndices.forEach(key => {
                            if (removed >= toRemove) return;
                            const type = key[0];
                            const index = parseInt(key.substring(1));
                            
                            // Aktif kullanƒ±mda olmayan texture'ƒ± temizle
                            if (type === 'u' && index !== currentUniverseIndex && index !== nextUniverseIndex) {
                                if (universeTextures[index]) {
                                    universeTextures[index].dispose();
                                    delete universeTextures[index];
                                    activeTextureIndices.delete(key);
                                    removed++;
                                }
                            } else if (type === 'p' && index !== currentPourIndex) {
                                if (pourTextures[index]) {
                                    pourTextures[index].dispose();
                                    delete pourTextures[index];
                                    activeTextureIndices.delete(key);
                                    removed++;
                                }
                            }
                        });
                    }
                    
                    // üî• EKSTRA: Garbage collection tetikle (tarayƒ±cƒ± destekliyorsa)
                    if (window.gc) {
                        window.gc();
                    }
                }
            }
        }

        // ============ YENƒ∞: AKI≈ûKAN SKYBOX BA≈ûLAT ============
        loadFluidTextures();
        
        // üîÑ SEKME DEƒûƒ∞≈ûƒ∞Mƒ∞ KONTROL√ú - TAMAMEN D√úZELTƒ∞LDƒ∞!
        let wasHidden = false;
        let hiddenTime = 0;  // Ne kadar s√ºre gizli kaldƒ±
        let lastVisibleTime = Date.now();  // Son g√∂r√ºn√ºr olduƒüu zaman
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Sekme gizlendi - zamanƒ± kaydet!
                wasHidden = true;
                hiddenTime = Date.now();
                console.log('üôà Sekme gizlendi!');
            } else {
                // Sekme geri geldi!
                if (wasHidden) {
                    const timeHidden = Date.now() - hiddenTime;  // Ka√ß ms gizli kaldƒ±
                    
                    console.log(`üëÄ Sekme geri geldi! ${Math.round(timeHidden/1000)}s gizliydi`);
                    
                    // üéØ ZAMAN OFFSET'ƒ∞ EKLE - Sanki hi√ß gitmemi≈ü gibi!
                    cycleStartTime += timeHidden;
                    lastSkyboxChange += timeHidden;
                    lastPourTextureChange += timeHidden;
                    
                    // Eƒüer √ßok uzun s√ºre gizli kaldƒ±ysa (5 dakikadan fazla), sƒ±fƒ±rla
                    if (timeHidden > 300000) {  // 5 dakika
                        console.log('‚ö†Ô∏è √áok uzun s√ºre gizli kaldƒ±, d√∂ng√º sƒ±fƒ±rlanƒ±yor!');
                        cycleStartTime = Date.now();
                        lastSkyboxChange = Date.now();
                        lastPourTextureChange = Date.now();
                    }
                    
                    wasHidden = false;
                }
            }
        });
        
        // üì± LOADING EKRANI KALDIRMA
        let assetsLoaded = {
            car: false,
            track: false,
            skybox: false
        };
        
        function checkAllLoaded() {
            if (assetsLoaded.car && assetsLoaded.track && assetsLoaded.skybox) {
                setTimeout(() => {
                    const loading = document.getElementById('loading');
                    if (loading) {
                        loading.style.transition = 'opacity 0.5s';
                        loading.style.opacity = '0';
                        setTimeout(() => loading.style.display = 'none', 500);
                    }
                }, 500);
            }
        }

        let frameCounter = 0;
        let animationId = null;  // ‚úÖ Track animation loop!
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            frameCounter++;
            
            // üì± Hafƒ±za kontrol√º frekansƒ± - cihaza g√∂re!
            const memoryCheckFreq = isTablet ? 240 : (isMobile ? 180 : 300);  // iPad: 4s, Phone: 3s, Desktop: 5s
            if (frameCounter % memoryCheckFreq === 0) {
                checkMemory();
            }
            
            // ============ YENƒ∞: AKI≈ûKAN SKYBOX G√úNCELLE ============
            updateFluidSkybox();
            
            // üåßÔ∏è YAƒûMURU G√úNCELLE
            updateRain();
            
            updateCar();
            updateCamera();
            
            if (car && spotLight) {
                spotLight.position.copy(car.position);
                spotLight.position.y += 25;
                spotLight.target.position.copy(car.position);
            }
            
            const delta = 0.016;
            mirrorMixers.forEach(mixer => mixer.update(delta));
            rotatingMirrors.forEach(obj => {
                obj.mesh.rotation.y += obj.rotationSpeed;
            });
            
            // ü™û Mirror update - ORƒ∞Jƒ∞NAL AYARLAR!
            const mirrorUpdateFreq = isTablet ? 6 : (isLowEnd ? 12 : 9);
            
            if (car && mirrorMeshes.length > 0 && frameCounter % mirrorUpdateFreq === 0) {
                mirrorMeshes.forEach(mesh => mesh.visible = false);
                
                cubeCamera.position.copy(car.position);
                cubeCamera.position.y += 3;
                
                if (fluidSkybox && fluidSkybox.material) {
                    fluidSkybox.material.side = THREE.DoubleSide;
                }
                
                cubeCamera.update(renderer, scene);
                
                if (fluidSkybox && fluidSkybox.material) {
                    fluidSkybox.material.side = THREE.BackSide;
                }
                
                mirrorMeshes.forEach(mesh => mesh.visible = true);
            }
            
            // üõ£Ô∏è Road camera position - HER FRAME Dƒ∞REKT TAKƒ∞P! (‚úÖ SADECE TABLET/DESKTOP!)
            if (car && !isPhone) {
                const targetPos = car.position.clone();
                targetPos.y += 6;  // 12 ‚Üí 6 (daha yakƒ±n, daha net!)
                smoothRoadCameraPos.lerp(targetPos, roadCameraLerpFactor);
            }
            
            // üõ£Ô∏è Road camera update - SADECE TABLET VE DESKTOP! ‚úÖ TELEFONDA KAPALI!
            if (!isPhone && car && trackMesh && roadCubeCamera) {
                const speed = Math.abs(carSpeed);
                const isMoving = speed > 0.01;
                const updateFreq = isTablet ? 
                    (isMoving ? 2 : 3) :  // iPad: Hƒ±zlƒ±!
                    (isMoving ? 4 : 6);   // Desktop: Normal
                
                if (frameCounter % updateFreq === 0) {
                    // üéØ 1. YOL + AYNALAR + ARABA Gƒ∞ZLE!
                    trackMesh.visible = false;
                    mirrorMeshes.forEach(mesh => mesh.visible = false);
                    if (car) car.visible = false;
                    
                    // üéØ 2. SMOOTH POZƒ∞SYON UYGULA!
                    roadCubeCamera.position.copy(smoothRoadCameraPos);
                    
                    // üéØ 3. SKYBOX DOUBLESIDE
                    if (fluidSkybox && fluidSkybox.material) {
                        fluidSkybox.material.side = THREE.DoubleSide;
                    }
                    
                    // üéØ 4. G√úNCELLE - Sadece skybox!
                    roadCubeCamera.update(renderer, scene);
                    
                    // üéØ 5. SKYBOX BACKSIDE
                    if (fluidSkybox && fluidSkybox.material) {
                        fluidSkybox.material.side = THREE.BackSide;
                    }
                    
                    // üéØ 6. YOL + AYNALAR + ARABA g√∂r√ºn√ºr!
                    trackMesh.visible = true;
                    mirrorMeshes.forEach(mesh => mesh.visible = true);
                    if (car) car.visible = true;
                }
            }
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
